#!/usr/bin/perl -w
use strict;
use Cwd;
use Getopt::Std;
use Parallel::ForkManager;

my $progName = $0;
$progName    =~ s/^.*\///;
$progName    =~ s/_v(\d+\.\d+)//;
my $version  = $1 || '3.2.2';
my $created  = '011017';
my $modified = '081417';

my %options;
# ABCDFGIMOSX
# abcdfhnpqrstxyz
getopts('I:S:F:A:D:M:B:C:X:O:G:p:hfadcqrstnxyz', \%options);

# Display help
if( ! %options ){
	MESSAGES::die_with_usage( $progName, $version, $created, $modified );
}
if( $options{'h'} or ! %options ){
	MESSAGES::print_usage( $progName, $version, $created, $modified );
	exit;
}

if( $options{'x'} or $options{'y'} or $options{'z'} ){
	# Print pipeline scheme
	MESSAGES::print_scheme( $progName, $version ) if $options{'x'};
	# Print example config file
	MESSAGES::print_configuration_file( $version ) if $options{'y'};
	# Print ARS config' file
	MESSAGES::print_ars_file() if $options{'z'};
	exit;
}

# Create output directory (if specified)
my $outDir = $options{'O'} || '.';
`mkdir -p $outDir`
	if $outDir;

# Configure the program
my $Config = new CONFIGURATION(
 	options => \%options,
	outDir  => $outDir,
);

#-------------------------------------------------------------------------------
# MAIN
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

print STDOUT "-------------------------------------------------------------------------------\n";
my $time0 = time;

# Processing input files
#-------------------------------------------------------------------------------
=pod
# Inputs:
I SRA_ID
S SRA
F FASTQ_read1:2 FASTQ_read2
A BAM
D DAT
=cut

# Get input type together with correct files
#-------------------------------------------------------------------------------
my $itype  = $Config->get_value('itype');
my @inputs = split( ',', $Config->get_value($itype) );
my $iNum   = scalar @inputs;

# Make the @bedFiles array recyclable for all BAM files
my $bedFiles = make_recycling_bedFiles( $Config, $iNum )
	if( $Config->get_value('B') );

my @datFiles;
for( my $i = 1; $i <= $iNum; $i++ ){
	my $input = $inputs[$i-1];
	my $bFile = $bedFiles->[$i-1] || 0;
	print STDOUT "\n>> Processing input \'$itype\' ($i/$iNum)\n";
	print STDOUT "  > $input\n\n";

	# Download SRA files from NCBI
	#-------------------------------------------------------------------------------
	if( $Config->get_value('I') ){
		print STDOUT "Retrieving SRA file from NCBI's server\n";
		print STDOUT "  > $input\n";

		my $Sra = new SRA(
			sra_id => $input,
			config => $Config,
			outDir => $outDir,
		);
		$Sra->download;

		$input = $Sra->get_file;
		$Config->set_value( 'S', $input );

		print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
	}
	# Continue if FASTQ files were requested
	next unless(
		$Config->get_value('f') or
		$Config->get_value('a') or
		$Config->get_value('d')
	);

	# Create FASTQ files from SRA files
	#-------------------------------------------------------------------------------
	my $qFlag = 0;
	if( $Config->get_value('S') ){
		print STDOUT "Generate FASTQ file from SRA file\n";
		print STDOUT "  > $input\n";

		my $Fastq = new FASTQ(
			config => $Config,
			outDir => $outDir,
		);
		$Fastq->generate( $input );

		if( $Config->get_value('q') ){
			$Fastq->quality_control;
			$qFlag = 1;
		}

		# Save SRA file (no longer in use)
		if( !$Config->get_value('SAVE_SRA') ){
			`rm -f $input 2> /dev/null`;
		}
		my $fastq1 = $Fastq->get_file1;
		my $fastq2 = $Fastq->get_file2;

		if( $fastq2 ){
			$input = "$fastq1:$fastq2";
		}
		else{
			$input = $fastq1;
		}
		$Config->set_value( 'F', $input );

		print STDOUT "\e[0;32m[ DONE ]\e[0m\n";

	}
	# Continue if BAM files were requested
	next unless(
		$Config->get_value('a') or
		$Config->get_value('d')
	);

	# Align reads to genome
	#-------------------------------------------------------------------------------
	my $rFlag;
	if( $Config->get_value('F') ){
		print STDOUT "Align reads to reference genome\n";

		my @jFiles = split( ':', $input );
		my $jFile1 = $jFiles[0];
		my $jFile2 = $jFiles[1];

		print STDOUT "  > $jFile1\n";
		print STDOUT "  > $jFile2\n" if $jFile2;

		my $Fastq = new FASTQ(
			config => $Config,
			outDir => $outDir,
		);
		$Fastq->set_file1( $jFile1 );
		$Fastq->set_file2( $jFile2 ) if $jFile2;

		if( $Config->get_value('q') and ! $qFlag ){
			$Fastq->quality_control;
		}

		# Align reads to genome
		my $Alignment = new ALIGNMENT(
			fastq  => $Fastq,
			config => $Config,
			outDir => $outDir,
		);
		$Alignment->align_to_genome;

		if( !$Config->get_value('r') ){
			$Alignment->remove_duplicates;
			$rFlag = 1;
		}

		# Save FASTQ files (no longer in use)
		if( !$Config->get_value('SAVE_FASTQ') ){
			`rm -f $jFile1 2> /dev/null`;
			`rm -f $jFile2 2> /dev/null` if $jFile2;
		}
		$input = $Alignment->get_file;
		$Config->set_value( 'A',  $input );

		print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
	}

	# Take BAM file as input and call peaks if no BED file is provided or it's not requested
	#-------------------------------------------------------------------------------
	my $sFlag;
	if( $Config->get_value('A') ){
		# Index and split BAM file by chromosomes
		print STDOUT "Index and split BAM file\n";
		print STDOUT "  > $input\n";

		my $Alignment = new ALIGNMENT(
			bamFile => $input,
			config  => $Config,
			outDir  => $outDir,
		);
		if( !$Config->get_value('r') and !$rFlag ){
			$Alignment->remove_duplicates;
		}

		if( $Config->get_value('c') and ! $bFile ){
			# Call peaks with MACS2
			print STDOUT "Call peaks from BAM file\n";
			print STDOUT "  > $input\n";

			# Split BAM file y chromosomes
			$Alignment->split_bam_by_chr;
			$sFlag = 1;

			my $Peaks = new PEAKS(
				bamFile => $Alignment->get_file,
				config  => $Config,
				outDir  => $outDir,
			);
			$Peaks->call_peaks;
			$Peaks->split_peaks_by_chr;
			# Count reads under peaks using chrom-split BAM files
			$Peaks->count_reads_under_peak( $Alignment->get_chr_files );

			# Save BED files
			$bFile = $Peaks->get_file;
			if( !$Config->get_value('SAVE_BED') ){
				`rm -f $bFile 2> /dev/null`;
			}
			# Remove per chromosome BED files (no longer used)
			`rm -f $outDir/chr*.bed 2> /dev/null`;
		}
		$Config->set_value( 'B', $bFile ) if $bFile;
		$input = $Alignment->get_file;

		# Find allele-dependent behavior (ADBs) if requested
		#---------------------------------------------------------------------------
		if( $Config->get_value('d') ){
			# Find allele-dependent behavior
			my $base = $input;
			$base    =~ s/^.*\///;
			$base    =~ s/.bam$//;
			# Create directory to deposit ADB file
			my $datFile = "$outDir/$base.dat";

			my $AD_behavior = new ADB(
				file   => $datFile,
				config => $Config,
				outDir => $outDir,
			);

			# Filter SNPs within peaks and split by chromosome
			# if genotyping data is to be used
			my $Genotyping = new GENOTYPING(
				outDir => $outDir,
				config => $Config,
			);
			print STDOUT "Load genotyping information\n";

			$Genotyping->load_file( $Config->get_value('G') );

			if( $Config->get_value('B') and ! $Config->get_value('b') ){
				my $gStatus = $Genotyping->filter( $bFile );
				next if !$gStatus;
			}
			$Genotyping->split_gen_by_chr;
			my $genFiles = $Genotyping->get_chr_files;

			print STDOUT "Find ADBs at heterozygous positions\n";
			$AD_behavior->find_allelic_behavior( $Alignment, $genFiles );

			# Save BAM file (no longer in use)
			if( !$Config->get_value('SAVE_BAM') ){
				`rm -f $input 2> /dev/null`;
			}
			# Save BED file (no longer in use)
			if( $bFile and ! $Config->get_value('SAVE_BED') ){
				`rm -f $bFile 2> /dev/null`;
			}
			# Remove GEN files (no longer in use)
			`rm -f $outDir/*.gen 2> /dev/null`;
			# Remove per chromosome DAT files (no longer in use)
			`rm -f $outDir/chr*.dat 2> /dev/null`;
			# Remove per chomosome BAM files (no longer in use)
			`rm -f $outDir/chr*.bam 2> /dev/null`;

			push( @datFiles, $datFile );
		}
		else{
			# Remove per chromosome BAM files (no longer used)
			`rm -f $outDir/chr*.bam $outDir/*.bai 2> /dev/null`;

			# Save BAM file (no longer in use)
			if( !$Config->get_value('SAVE_BAM') ){
				`rm -f $input 2> /dev/null`;
			}
		}
		print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
	}

	# Load DAT files
	#---------------------------------------------------------------------------
	if( $Config->get_value('D') ){
		# Save DAT files into array for further processing
		push( @datFiles, $input );
	}
}
# Exit the program if ADBs were NOT requested
exit if !$Config->get_value('d');

# Save DAT files
$Config->set_value( 'D', join( ',', @datFiles ) );
print STDOUT "DAT files: @datFiles\n";

# Annotate DAT files
#-------------------------------------------------------------------------------
if( $Config->get_value('D') ){
	# Second phase: obtain final results from all experiments
	print STDOUT "\n\e[0;36mINFO: Preparing results\e[0m\n";

	my @iFiles = split( ',', $Config->get_value('D') );

	# Load up the FDR lookup table
	print STDOUT "Load ARS table\n";

	my $ArScores = new ARS(
		file   => $Config->get_value('ARS_FILE'),
		outDir => $outDir,
		config => $Config,
	);
	print STDOUT "\e[0;32m[ DONE ]\e[0m\n";

	# Make a selection based on given config
	print STDOUT "Merge allele-dependent candidate SNPs\n";
	my $adbFile = "$outDir/results.adb";

	my $Postprocess = new POSTPROCESSING(
		file   => $adbFile,
		config => $Config,
		outDir => $outDir,
	);
	$Postprocess->merge_positions( \@iFiles );
	$Postprocess->add_statistics;
	$Postprocess->add_ars( $ArScores );
	$Postprocess->add_reference_bases;

	$Postprocess->find_motif_matches( $Config->get_value('M') )
		if $Config->get_value('M');

	if( $Config->get_value('n') ){
		my $annoFlag = $Postprocess->annotate( 'DISEASE' )
			if $Config->get_value('DISANNO_FILE');

		my $fields = 0;
		$fields    = 6 if $annoFlag;
		$Postprocess->annotate( 'GENE', $fields )
			if $Config->get_value('GENANNO_FILE');
	}
	print STDOUT "\e[0;32m[ DONE ]\e[0m\n";

	# Sort files in descending order by ARS values
	`head -n1 $adbFile > $adbFile.sorted`;
	`tail -n +2 $adbFile | sort -nrk15,15 >> $adbFile.sorted`;
	`mv -f $adbFile.sorted $adbFile`;

	# Save ADB file to $outDir
	my $sFile = $adbFile;
	$sFile    =~ s/^.*\//$outDir\//;
	`cp -f $adbFile $sFile 2> /dev/null`;

	if( $Config->get_value('M') ){
		# Save HIT file to $outDir
		my $hitFile = $Postprocess->get_hitFile;
		$sFile      = $hitFile;
		$sFile      =~ s/^.*\//$outDir\//;
		`cp -f $hitFile $sFile 2> /dev/null`;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "\n\e[0;36mTotal time elapsed: $elapsed min\e[0m\n";
	print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
}

exit;



#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

# SUBROUTINES
#-------------------------------------------------------------------------------

sub make_recycling_bedFiles
{
	my $Config = shift;
	my $iNum       = shift;
	my $bFiles     = $Config->get_value('B');
	my @bedFiles;

	if( $bFiles )	{
		@bedFiles = split( ',', $bFiles );
		my $bNum  = scalar @bedFiles;

		if( $bNum < $iNum )		{
			do{
				@bedFiles = ( @bedFiles, @bedFiles );
				$bNum = scalar @bedFiles;
			}
			until( $bNum >= $iNum );
		}
	}

	return \@bedFiles;
}

sub add_cse_column
{
	my $file   = shift;
	my $output = $file . ".tmp";
	open( IN, $file ) or
	(
	 	print STDOUT "  ERROR: Could not open file $file at 'add_cse_column'\n" and
		return 0
	);
	open( OUT, ">$output" ) or
		die "ERROR: Could not create file $output at 'add_cse_column'\n";

	my $header = <IN>;
	chomp $header;
	my @header = split( "\t", $header );
	splice( @header, 3, 0, "UCSC_COOR" );
	print OUT join( "\t", @header ), "\n";

	while( my $line = <IN> )
	{
		chomp $line;
		my @split = split( "\t", $line );
		my $chr   = $split[0];
		my $start = $split[1];
		my $end   = $split[2];
		my $coor  = "$chr:$start-$end";
		splice( @split, 3, 0, $coor );
		print OUT join( "\t", @split ), "\n";
	}

	`head -n1 $output > $file`;
	`tail -n +2 $output | sort -u | sort -grk18,18 >> $file`;
	`rm -f $output`;

	return 1;
}

#-------------------------------------------------------------------------------
package MESSAGES;
use warnings;
use strict;

sub die_with_usage
{
	my $progName = shift;
	my $version  = shift;
	my $created  = shift;
	my $modified = shift;

	die"
\n\e[0;33m================================================================================\e[0m

\e[0;33mMARIO (Measurement of Allelic Ratio Informatics Operator) pipeline\e[0m

\e[0;33mVersion:    $version\e[0m
\e[0;33mWritten by: Mario Pujato

\e[0;33m================================================================================\e[0m

\e[1;31mUse option -h for help\e[0m\n\n";
}

sub print_usage
{
	my $progName = shift;
	my $version  = shift;
	my $created  = shift;
	my $modified = shift;
	#getopts('I:S:1:2:B:D:b:p:C:h', \%options);

	print STDOUT "
\e[0;33m================================================================================\e[0m

\e[0;33mMARIO (Measurement of Allelic Ratio Informatics Operator) pipeline\e[0m

\e[0;33mVersion:    $version\e[0m
\e[0;33mWritten by: Mario Pujato

\e[0;33m================================================================================\e[0m

\e[1;33mUSAGE: $progName [options] <arguments>\e[0m

  [options]

    ARGUMENTS
      -O  Name of output folder
      -C  Configuration file (a sample file can be generated using option -y)

      -I  SRA IDs. Comma-separated list
            Based on these IDs, SRA files will be downloaded from NCBI
      -S  SRA files. Comma-separated list
      -F  FASTQ files (paired-end reads experiments). Comma-separated list
            Paired-end reads experiments should be given in pairs, separated by \":\"
            (example: EXP1_FQ1:EXP1_FQ2,EXP2_FQ1:EXP2_FQ2,EXP3_FQ,EXP4_FQ...)
      -A  Alignment files (BAM format). Comma-separated list
            The file must be sorted
            Duplicate reads will be removed unless the -r option is set
      -D  DAT files. Comma-separated list
            This is the raw output of the MARIO pipeline (one per BAM file)
            Given these files, the pipeline will score and annotate the ADB
            predictions

      -X  Path to index files (STAR, HISAT2 and BOWTIE2 are supported)
            For BOWTIE2, add to the end of the index path the base name common
             to all the .bt2 files, like /path_to_index_files/hg19
            For HISAT2, add to the end of the index path the base name common
             to all the .ht2 files, like /path_to_index_files/hg19
            For STAR, nothing need to be added to the index path
      -G  Genotyping file containing ONLY heterozygous positions
            4-column format: CHR START END STATUS (TAB delimited)
		    The field STATUS takes values 0:genotyped and 1:imputed
      -p  (opional) Number of threads to use in parallelized routines
            (it defaults to use all available threads)

      -B  (optional) BED files. Comma-separated list
            (must match BAM files or will be recycled for all BAM files)
      -M  (optional) Motif files
            (provided as a single file listing motif files)

    RNA-SEQ
      -s  Process RNA-seq experiment using the STAR aligner (34Gb o memory required!)
      -t  Process RNA-seq experiment using the HISAT2 aligner (low memory usage)

          If neither -s nor -t options are given, the program uses the BOWTIE2 aligner,
            which is better suited for CHIP-seq experiments

    SWITCHES
      -h  This help message

      -f  Generate FASTQ files from SRA files
      -a  Align FASTQ files to genome
      -d  Find and report ADBs
      -c  Call peaks from BAM file
      -q  Perform quality control of raw-reads (for each FASTQ file)
      -n  Annotate ADB results
            It will use the GENANNO_FILE and/or DISANNO_FILE specified in the configuration file

      -r  Retain duplicate reads in BAM output
            (the default behavior is to remove duplicate reads)
      -b  Do not require het-SNPs to fall within peaks
            (the default behavior id to require het-SNPs to fall within peaks)

      -x  Print pipeline scheme to the screen
      -y  Generate a default configuration file
      -z  Generate a default Allelic reproducibility score (ARS) file

\e[0;33m================================================================================\e[0m\n\n";

	return 1;
}

sub print_scheme
{
	my $progName = shift;
	my $version  = shift;

	print "
\e[0;33m================================================================================\e[0m

\e[0;33mScheme of the MARIO pipeline\e[0m

\e[0;33mVersion:    $version\e[0m
\e[0;33mWritten by: Mario Pujato

\e[0;33m================================================================================\e[0m

The pipeline can be used to start and/or generate any intermediate file in the scheme.

\e[1;32m+-----------------------------------------------------------+\e[0m
\e[1;32m|                                                           |\e[0m
\e[1;32m| +-----[I]                       +-----[B]       +-----[G] |\e[0m
\e[1;32m| | SRAID |                       |  BED  | ----> |  GEN  | |\e[0m
\e[1;32m| +-------+                       +-------+  (b)  +-------+ |\e[0m
\e[1;32m|     |                               ^               |     | \e[0m
\e[1;32m|     |                               | (c)           |     |\e[0m
\e[1;32m|     v                               |               v     |\e[0m
\e[1;32m| +-----[S]       +-----[F]       +-----[A]       +-----[D] |       +=======+       +-----[C]\e[0m
\e[1;32m| |  SRA  | ----> | FASTQ | ----> |  BAM  | ----> |  DAT  | | ----> |  ADB  | <---- | ANNOT |\e[0m
\e[1;32m| +-------+  (f)  +-------+  (a)  +-------+  (d)  +-------+ |       +=======+  (n)  +-------+\e[0m
\e[1;32m|                    (q)              ^                     |           |\e[0m
\e[1;32m|                                     |                     |           |\e[0m
\e[1;32m|                                     |                     |           v\e[0m
\e[1;32m|                                 +-----[X]                 |       +=======+       +-----[M]\e[0m
\e[1;32m|                                 | INDEX |                 |       |  HIT  | <---- | MOTIF |\e[0m
\e[1;32m|                                 +-------+                 |       +=======+       +-------+\e[0m
\e[1;32m|                                                           |\e[0m
\e[1;32m+-----------------------------------------------------------+\e[0m

Input files:

-I  SRA ID (i.e. SRR1608989 )
-S  SRA file (i.e. SRR1608989.sra)
-F  Fastq file (paired-end reads should be given separated with \":\", like: FQ1:FQ2)
-A  Alignment file (BAM format)
-D  DAT file (first ouput of the MARIO pipeline containing raw allelic counts)

Priority of input files:
  If multiple input files are privided (e.g.: SRA_ID, FASTQ and BAM files),
  the pipeline starts with the file with the highest priority.

  I<S<F<A<D (the DAT file has the highest priority)

-G  Genotyping file with heterozygous positions
-X  Index files for corresponding aligner (STAR, HISAT2 and BOWTIE2 are supported)
      For BOWTIE2, add to the end of the index path the base name common
       to all the .bt2 files, like /path_to_index_files/hg19
      For HISAT2, add to the end of the index path the base name common
       to all the .ht2 files, like /path_to_index_files/hg19
      For STAR, nothing need to be added to the index path
-C  Configuration file (can be generated with the -y option)
-M  (optional) File with a list of motifs (PWMs)

-f  Generate FASTQ files from SRA files
-a  Align FASTQ reads to the genome (generates BAM file)
-d  Find positions with ADBs (allele-dependent behavior)

-B  (optional) Peaks file in BED format
-O  Name of output folder (all files are saved here)
-c  Call peaks
-b  Do not require het-SNPs to fall within peaks
-n  Annotate ADB results
      It will use the GENANNO_FILE and/or DISANNO_FILE specified in the configuration file
-p  Number of threads (default: use all available threads)
-q  Perform quality control on FASTQ files
-r  Keep duplicate reads
-s  Input data is RNA-seq (STAR alignment)
-t  Input data is RNA-seq (HISAT2 alignment)

Output files:
(ADB) Allele-dependent behavior at each heterozygous positions, including
      reproducibility score (ARS) and annotations
(HIT) If motif files are given, the ADB file is further annotated with motif
      hits on each heterozygous position

Examples:
  Download SRA file from NCBI based on SRR ID (the downloaded SRA file is 89Mb in size)
    > MARIO -I SRR1608989
    > MARIO -I SRR1608989,SRR1608990   (this one downloads two SRA files -89Mb and 99Mb files)

  Download and generate FASTQ files from SRR ID
    > MARIO -fI SRR1608989 -C config_3.2.txt

  ChIP-seq experiments or similar:
  Align FASTQ reads to hg19 genome (starting from downloaded SRA file)
    > MARIO -aS SRR1608989.sra -C config_3.2.txt -X path_to_BOWTIE2_aligner_index_files/hg19

  RNA-seq experiments:
  Align FASTQ reads to hg19 genome (starting from downloaded SRA file)
    > MARIO -aS SRR1608989.sra -C config_3.2.txt -sX path_to_STAR_aligner_index_files
    > MARIO -aS SRR1608989.sra -C config_3.2.txt -tX path_to_HISAT2_aligner_index_files/hg19

  Align to genome using paired-end reads
    > MARIO -aF SRR1_1.fq.gz:SRR1_2.fq.gz -C config_3.2.txt -sX path_to_STAR_aligner_index_files

  Align to genome using single and paired-end reads from different experiments
    > MARIO -aF SRR1_1.fq.gz:SRR1_2.fq.gz,SRR2.fq.gz -C config_3.2.txt -sX path_to_STAR_aligner_index_files

  Call peaks on BAM files
    > MARIO -cA SRR1.bam,SRR2.bam -C config_3.2.txt

  Find ADBs from BAM files
    > MARIO -dA SRR1.bam,SRR2.bam -C config_3.2.txt -G path_to_genotyping_file/hetpos.txt

\e[0;33m================================================================================\e[0m\n\n";

	return 1;
}

sub print_configuration_file
{
	my $version = shift;

	my $text =
"#-------------------------------------------------------------------------------
# Files
#-------------------------------------------------------------------------------

# Genotype files are located in:
# /home/mario/Databases/genotyping_data/hetSNPs
# /data/weirauchlab/databank/genomes/hg19/genotyping_data/hetSNPs # Cluster

# Bowtie2 index files are located in:
# /home/mario/Databases/Hsap/aligner_indices/BOWTIE2
# /data/weirauchlab/databank/genomes/hg19/index/BOWTIE2 # Cluster

# STAR index files (hets not masked) are located in:
# /home/mario/Databases/Hsap/aligner_indices/STAR/hg19
# /data/weirauchlab/databank/genomes/hg19/index/STAR/hg19 # Cluster

# Motif files (for ChIP-seq experiments) are located in:
# /home/mario/Databases/matrices/cisbp_matrices/motif_lists
# /data/weirauchlab/databank/genomes/hg19/cisbp_matrices/motif_lists # Cluster

# DB SNP 147 single file (use this file in case there is no available genotyping data) is located in:
# /home/mario/Databases/genotyping_data/hetSNPs/dbSNP147_single.txt
# /data/weirauchlab/databank/genomes/hg19/genotyping_data/hetSNPs/dbSNP147_single.txt # Cluster

# Human genome FASTA file
REFGEN_FILE  = /home/mario/Databases/Hsap/hg19/hg19.fa
#REFGEN_FILE  = /data/weirauchlab/databank/genomes/hg19/hg19.fa # Cluster
# Zebrafish genome FASTA file
#REFGEN_FILE  = /home/mario/Databases/danRer7/danRer7.fa
#REFGEN_FILE  = /data/weirauchlab/databank/genomes/danRer7/danRer7.fa # Cluster

# BED file containing disease-associated SNPs information
DISANNO_FILE = /home/mario/Documents/CCHMC_postdoc/Projects/Allele_specific_variants/SDataB_VariantsUsedForEachPhenotype.bed
#DISANNO_FILE = /data/weirauchlab/databank/apps/MARIO/SDataB_VariantsUsedForEachPhenotype.bed # Cluster

# BED file containing regions used for gene annotations
GENANNO_FILE = /home/mario/Databases/Hsap/hg19/hg19_exons_anno.bed
#GENANNO_FILE = /data/weirauchlab/databank/apps/MARIO/hg19_exons_anno.bed # Cluster

#-------------------------------------------------------------------------------
# Configuration parameters
#-------------------------------------------------------------------------------

# Chromosomes to consider (comma-separated list):
# Comment out the desired \'CHROMOSOMES\' line
# Human
CHROMOSOMES = chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chr20,chr21,chr22,chrX,chrY
# Mouse
#CHROMOSOMES = chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chrX,chrY
# Zebrafish
#CHROMOSOMES = chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chr20,chr21,chr22,chr23,chr24,chr25

# ADB (Allele-Dependent Behavior) configuration parameters:
S_READS_CF  = 5     # Minimum number of reads (strong reads) to filter out ADB results
W_READS_CF  = 30    # Minimum number of reads (weak reads) to filter out ADB results when no genotyping information is available

# Motif searching configuration parameters:
SNP_PADD    = 20    # Number of base pairs to consider at each side of a SNP for motif searching
                    # Twice this value should encompass the whole length of virtually any motif
MOODS_PVAL  = 0.01  # P-value cutoff for the program MOODS (recommended: 0.01)
MIN_SCORE   = 0.5   # Minimum normalized motif match score to report (it applies to the strong allele)

# Optional configuration parameters
PEAK_RPKM   = 0.4   # Minimum RPKM value used to remove spurious peaks
PEAK_WIDTH  = 200   # Minimum peak width used to remove spurious peaks
PEAK_EXT    = 50    # Number of base pairs to extend called peaks on both sides
                    # MACS2 calls peaks using medium height or something similar, therefore this ensures that peak tails are included


#-------------------------------------------------------------------------------
# Switches for saving files (0 = off; 1 = on)
#-------------------------------------------------------------------------------

SAVE_SRA   = 0  # Save SRA files
SAVE_FASTQ = 0  # Save FASTQ files
SAVE_BAM   = 0  # Save alignment files (BAM format)
SAVE_BED   = 1  # Save peak files (BED format)


#-------------------------------------------------------------------------------
# External programs (include path here if the program is not in the system's path)
#-------------------------------------------------------------------------------

FASTQC     = fastqc
FASTQDUMP  = fastq-dump
#FASTQDUMP  = /data/weirauchlab/team/puj6ug/bin/fastq-dump  # Cluster
HISAT2     = hisat2
BOWTIE2    = bowtie2
STAR       = STAR
SAMTOOLS   = samtools
BEDTOOLS   = bedtools
PICARD     = picard-tools MarkDuplicates
#PICARD     = java -Xmx6g -jar /usr/local/picard/1.89/jar/MarkDuplicates.jar  # Cluster
MACS2      = macs2
MOODS      = moods\n";

	my @lines = split( "\n", $text );
	open( OUT, ">config_$version.txt" ) or
		die "ERROR: Could not write config' file\n";
	print OUT $text;
	close OUT;

	return 1;
}

sub print_ars_file
{
	open( OUT, ">ARS_table.txt" ) or
		die "ERROR: Could not write ARS file\n";

	print OUT "EXP	WS_RATIO	A	B
1	0.00	-0.84	0.15
1	0.10	-0.83	0.15
1	0.20	-0.81	0.15
1	0.30	-0.79	0.15
1	0.40	-0.73	0.15
1	0.50	-0.65	0.15
1	0.60	-0.55	0.15
1	0.70	-0.44	0.15
1	0.80	-0.36	0.15
1	0.90	-0.30	0.15
1	1.00	-0.26	0.15
2	0.00	-0.90	0.50
2	0.10	-0.89	0.50
2	0.20	-0.87	0.50
2	0.30	-0.84	0.50
2	0.40	-0.80	0.45
2	0.50	-0.75	0.40
2	0.60	-0.64	0.35
2	0.70	-0.52	0.35
2	0.80	-0.40	0.40
2	0.90	-0.33	0.45
2	1.00	-0.30	0.50
3	0.00	-0.98	1.25
3	0.10	-0.97	1.25
3	0.20	-0.94	1.25
3	0.30	-0.91	1.25
3	0.40	-0.86	1.25
3	0.50	-0.79	1.25
3	0.60	-0.69	1.25
3	0.70	-0.56	1.25
3	0.80	-0.45	1.25
3	0.90	-0.38	1.25
3	1.00	-0.36	1.25\n";

	return 1;
}

1;

#-------------------------------------------------------------------------------
package FILE;
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $file      = $arguments{'file'} or
		die "ERROR: Please provide an argument for 'file'\n";
	my $outDir    = $arguments{'outDir'} or
		die "ERROR: Please provide an argument for 'outDir'\n";

	my $self =
	{
		file       => $file,
		directory  => undef,
		base       => undef,
		extension  => undef,
		fileHandle => undef,
		outDir     => $outDir,
	};
	bless( $self, $class );

	$self->_parse_file_name;

	return $self;
}

sub file_exists
{
	my $self = shift;
	my $file = $self->{'file'};

	return 1 if -s $file;
	return 0;
}

sub get_file
{
	my $self = shift;
	return $self->{'file'};
}

sub get_directory
{
	my $self = shift;
	return $self->{'directory'};
}

sub get_name
{
	my $self = shift;
	my $base = $self->{'base'};
	my $ext  = $self->{'extension'};

	return "$base.$ext";
}

sub get_base
{
	my $self = shift;
	return $self->{'base'};
}

sub get_extension
{
	my $self = shift;
	return $self->{'extension'};
}

sub get_outDir
{
	my $self = shift;
	return $self->{'outDir'};
}

sub _parse_file_name
{
	my $self = shift;
	my $file = $self->{'file'};

	# Retrieve file name with full path
	$file    = `readlink -f $file`;
	chomp $file;

	# Extract full path, base name and extension
	$file    =~ /^(.*)\/(.+)\.(\w+)$/;
	my $dir  = $1;
	my $base = $2;
	my $ext  = $3;

	$self->{'directory'} = $dir;
	$self->{'base'}      = $base;
	$self->{'extension'} = $ext;

	return 1;
}

# Make a copy of the file to outDir and
# changes all attributes to point to this file
sub make_copy
{
	my $self   = shift;
	my $outDir = $self->get_outDir;
	my $file   = $self->get_file;
	my $name   = $self->get_name;

	`cp -f "$file" "$outDir/$name"`;

	$self->{'file'} = "$outDir/$name";
	$self->_parse_file_name;

	return 1;
}

sub set_file
{
	my $self = shift;
	my $file = shift;

	$self->{'file'} = $file;
	$self->_parse_file_name;

	return 1;
}

sub Open
{
	my $self = shift;
	my $file = $self->{'file'};

	open( my $FH, $file ) or
		die "ERROR: Could not open file $file\n";
	$self->{'fileHandle'} = $FH;

	return $FH;
}

sub Write
{
	my $self = shift;
	my $file = $self->{'file'};

	open( my $FH, ">$file" ) or
		die "ERROR: Could not open file $file\n";
	$self->{'fileHandle'} = $FH;

	return $FH;
}

sub Close
{
	my $self = shift;
	my $FH   = $self->{'fileHandle'};
	close $FH;

	return 1;
}

1;

#-------------------------------------------------------------------------------
package CONFIGURATION;
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $options   = $arguments{'options'};
    my $outDir    = $arguments{'outDir'};

	my $self = {
		configuration => undef, # {name} = value
	};
	bless( $self, $class );

	# Get input with the highest priority
	$self->_configure( $options );

#	print STDOUT "\e[0;32m[ DONE ]\e[0m\n";

	return $self;
}

sub set_value
{
	my $self      = shift;
	my $confName  = shift;
	my $confValue = shift;
	my $config    = $self->{'configuration'};

	$config->{$confName} = $confValue;

	return 1;
}

sub get_value
{
	my $self     = shift;
	my $confName = shift;
	my $config   = $self->{'configuration'};

	if( defined $config->{$confName} ){
		return $config->{$confName};
	}
	else{
		return 0;
	}
}

sub _configure
{
	my $self    = shift;
	my $options = shift;
	my %include;

	# Available processors
	my $proc        = `nproc`; chomp $proc;
	$options->{'p'} = $options->{'p'} || $proc;

	# Process option priorities
	# Options: f,a,d
	#-------------------------
	if( $options->{'f'} ){
		delete $options->{'a'};
		delete $options->{'d'};
	}
	elsif( $options->{'a'} ){
		delete $options->{'d'};
	}
	#-------------------------

	# Process input priorities
	# options: 'I:S:1:2:A:D'
	#-------------------------
	my $inputFile = 'ZZ';
	if( $options->{'D'} ){
		$inputFile    = 'D';
		$include{'D'} = 1;

		# Extract config from configuration file
		_load_configuration_file( $options );

		# Require d-group options
		_require_d_group_options( $options, \%include );
		_require_n_group_options( $options, \%include )
			if $options->{'n'};

		# Remove unnecessary options
		delete $include{'G'};
	}
	elsif( $options->{'A'} ){
		$inputFile      = 'A';
		$include{'A'}   = 1;
		$options->{'a'} = 1;
		$include{'a'}   = 1;

		# Include all files that may need to be saved
		$include{'SAVE_BAM'} = 1;
		$include{'SAVE_BED'} = 1;

		# Extract config from configuration file
		_load_configuration_file( $options );

		# if the BAM file is given, make sure it's not erased at the end!
		$options->{'SAVE_BAM'} = 1;

		# Require c-group  options
		if( $options->{'c'} ){
			_require_c_group_options( $options, \%include );
		}
		elsif( $options->{'B'} ){
			$include{'B'}          = 1;
			$options->{'SAVE_BED'} = 1;
		}

		# Require d-group options
		if( $options->{'d'} ){
			_require_d_group_options( $options, \%include );
			_require_n_group_options( $options, \%include )
				if $options->{'n'};
		}
	}
	elsif( $options->{'F'} ){
		$inputFile    = 'F';
		$include{'F'} = 1;

		# Include all files that may need to be saved
		$include{'SAVE_FASTQ'} = 1;
		$include{'SAVE_BAM'}   = 1;
		$include{'SAVE_BED'}   = 1;

		# Extract config from configuration file
		_load_configuration_file( $options );

		# if the FASTQ file is given, make sure it's not erased at the end!
		$options->{'SAVE_FASTQ'} = 1;

		if( $options->{'q'} ){
			_require_program( $options, 'FASTQC' );
			$include{'FASTQC'} = 1;
			$include{'q'}      = 1;
		}

		if( $options->{'c'} ){
			_require_c_group_options( $options, \%include );
			$options->{'a'} = 1;
			$include{'a'}   = 1;
		}
		elsif( $options->{'B'} ){
			$include{'B'}          = 1;
			# if the BED file is given, make sure it's not erased at the end!
			$options->{'SAVE_BED'} = 1;
		}

		# Require a-group and/or c-group  options
		if( $options->{'a'} or $options->{'d'} ){
			_require_a_group_options( $options, \%include );
		}

		# Require d-group options
		if( $options->{'d'} ){
			_require_d_group_options( $options, \%include );
			_require_n_group_options( $options, \%include )
				if $options->{'n'};
		}
	}
	elsif( $options->{'S'} ){
		$inputFile      = 'S';
		$include{'S'}   = 1;
		$options->{'f'} = 1;
		$include{'f'}   = 1;

		# Include all files that may need to be saved
		$include{'SAVE_SRA'}   = 1;
		$include{'SAVE_FASTQ'} = 1;
		$include{'SAVE_BAM'}   = 1;
		$include{'SAVE_BED'}   = 1;

		# Extract config from configuration file
		_load_configuration_file( $options );

		# if the SRA file is given, make sure it's not erased at the end!
		$options->{'SAVE_SRA'} = 1;

		# Require f-group options
		_require_program( $options, 'FASTQDUMP' );
		$include{'FASTQDUMP'} = 1;

		if( $options->{'q'} ){
			_require_program( $options, 'FASTQC' );
			$include{'FASTQC'} = 1;
			$include{'q'}      = 1;
		}

		if( $options->{'c'} ){
			_require_c_group_options( $options, \%include );
			$options->{'a'} = 1;
			$include{'a'}   = 1;
		}
		elsif( $options->{'B'} ){
			$include{'B'}          = 1;
			# if the BED file is given, make sure it's not erased at the end!
			$options->{'SAVE_BED'} = 1;
		}

		# Require a-group and/or c-group  options
		if( $options->{'a'} or $options->{'d'} ){
			_require_a_group_options( $options, \%include );
		}

		# Require d-group options
		if( $options->{'d'} ){
			_require_d_group_options( $options, \%include );
			_require_n_group_options( $options, \%include )
				if $options->{'n'};
		}
	}
	elsif( $options->{'I'} ){
		$inputFile    = 'I';
		$include{'I'} = 1;

		# Include all files that may need to be saved
		$include{'SAVE_SRA'}   = 1;
		$include{'SAVE_FASTQ'} = 1;
		$include{'SAVE_BAM'}   = 1;
		$include{'SAVE_BED'}   = 1;

		# Extract config from configuration file
		_load_configuration_file( $options );

		if( $options->{'c'} ){
			_require_c_group_options( $options, \%include );
			$options->{'a'}      = 1;
			$include{'a'}        = 1;
		}
		elsif( $options->{'B'} ){
			$include{'B'}          = 1;
			# if the BED file is given, make sure it's not erased at the end!
			$options->{'SAVE_BED'} = 1;
		}

		if( $options->{'q'} ){
			_require_program( $options, 'FASTQC' );
			$include{'FASTQC'} = 1;
			$include{'q'}      = 1;
			$options->{'f'}    = 1;
		}

		# Require f-group options
		if( $options->{'f'} or $options->{'a'} or $options->{'d'} ){
			$include{'f'} = 1;
			_require_program( $options, 'FASTQDUMP' );
			$include{'FASTQDUMP'} = 1;
		}

		# Require a-group and/or c-group  options
		if( $options->{'a'} or $options->{'d'} ){
			_require_a_group_options( $options, \%include );
		}

		# Require d-group options
		if( $options->{'d'} ){
			_require_d_group_options( $options, \%include );
			_require_n_group_options( $options, \%include )
				if $options->{'n'};
		}
	}
	#-------------------------
	$self->{'configuration'}{'itype'} = $inputFile;

	# Include common options
	$options->{'O'} = $options->{'O'} || './';
	$include{'O'}   = 1;
	$include{'p'}   = 1;
	$include{'r'}   = 1;

	print STDOUT "\n\e[1;31mConfiguration:\e[0m\n\n";
	for my $conf ( keys %$options ){

		if( $include{$conf} ){
			my $value = $options->{$conf};

			if( defined $value ){
				printf STDOUT ( "%14s: %s\n", $conf, $value );

				if( $conf eq 'CHROMOSOMES' ){
					my @chrom = split( ',', $value );
					$value    = \@chrom;
				}
				$self->{'configuration'}{$conf} = $value;
			}
			else{
				die "ERROR: A value for option \"$conf\" is missing\n";
			}
		}
	}
	print STDOUT "\n-------------------------------------------------------------------------------\n";

	return 1;
}

sub _load_configuration_file
{
	my $options = shift;

	# Require option P
	_require_file( $options, 'C' );

	my $confFile = $options->{'C'};
	open( IN, $confFile ) or
		die "ERROR: Could not open configuration file \"$confFile\"\n";

	while( my $line = <IN> ){
		chomp $line;
		next if $line =~ /^\s*$/;
		next if $line =~ /^\s*#/;

		my $conf  = $line;
		my $value = $line;
		$conf     =~ s/\s*=.*$//;
		$value    =~ s/^.*=\s*//;
		$value    =~ s/\s*#.*$//;

		if( $conf and defined $value ){
			$value          =~ s/\/+$//;
			$options{$conf} = $value;
		}
		else{
			print STDOUT "WARNING: Failed retrieving configuration line:\n  $line\n";
		}
	}
	close IN;

	return 1;
}

sub _require_file
{
	my $options = shift;
	my $conf    = shift;
	my $addon   = shift;

	if( $options->{$conf} ){
		my @split = split( /[,:]/, $options->{$conf} );

		for my $file ( @split ){
			$file = $options->{$conf} . $addon if $addon;

			# Check file is provided
			die "ERROR: Required file, \"$file\" in option \"$conf\", does not exist\n"
				if !-s $file;
		}
	}
	else{
		die "ERROR: Option \"$conf\" is missing\n";
	}
	return 1;
}

sub _require_program
{
	# Check program exists and it's functional
	my $options = shift;
	my $conf    = shift;
	my $status;

	if( $options->{$conf} ){
		$status = `type -a $options->{$conf} 2> /dev/null`;
	}
	else{
		die "ERROR: Option \"$conf\" is missing\n";
	}
	die "ERROR: Required command \"$conf\" not found\n"
		if !$status;

	return 1;
}

sub _require_a_group_options
{
	my $options     = shift;
	my $include     = shift;
	$options->{'a'} = 1;
	$include->{'a'} = 1;

	_require_program( $options, 'SAMTOOLS' );
	$include->{'SAMTOOLS'} = 1;

	if( $options->{'s'} ){
		_require_file( $options, 'X', '/SAindex' );
		_require_program( $options, 'STAR' );
		$include->{'s'}       = 1;
		$include->{'STAR'}    = 1;
		$include->{'X'}       = 1;
	}
	elsif( $options->{'t'} ){
		_require_file( $options, 'X', '.1.ht2' );
		_require_program( $options, 'HISAT2' );
		$include->{'t'}       = 1;
		$include->{'HISAT2'}  = 1;
		$include->{'X'}       = 1;
	}
	else{
		_require_file( $options, 'X', '.1.bt2' );
		_require_program( $options, 'BOWTIE2' );
		$include->{'BOWTIE2'} = 1;
		$include->{'X'}       = 1;
	}

	if( $options->{'r'} ){
		_require_program( $options, 'PICARD' );
		$include->{'PICARD'} = 1;
		$include->{'r'}      = 1;
	}

	return 1;
}

sub _require_c_group_options
{
	my $options = shift;
	my $include = shift;

	_require_program( $options, 'MACS2' );
	_require_program( $options, 'SAMTOOLS' );
	_require_file( $options, 'REFGEN_FILE' );
	$include->{'CHROMOSOMES'} = 1;
	$include->{'REFGEN_FILE'} = 1;
	$include->{'SAMTOOLS'}    = 1;
	$include->{'MACS2'}       = 1;
	$include->{'PICARD'}      = 1;
	$include->{'PEAK_EXT'}    = 1;
	$include->{'PEAK_RPKM'}   = 1;
	$include->{'PEAK_WIDTH'}  = 1;
	$include->{'c'}           = 1;
	$options->{'SAVE_BED'}    = 1;

	return 1;
}

sub _require_d_group_options
{
	my $options     = shift;
	my $include     = shift;
	$options->{'d'} = 1;
	$include->{'d'} = 1;

	_require_file( $options, 'G' );
	$include->{'G'} = 1;

	if( $options->{'M'} ){
		_require_file( $options, 'M' );
		_require_program( $options, 'MOODS' );
		$include->{'M'}          = 1;
		$include->{'MOODS'}      = 1;
		$include->{'SNP_PADD'}   = 1;
		$include->{'MOODS_PVAL'} = 1;
		$include->{'MIN_SCORE'}  = 1;
	}
	_require_file( $options, 'REFGEN_FILE' );
	_require_program( $options, 'BEDTOOLS' );
	_require_program( $options, 'SAMTOOLS' );
	MESSAGES::print_ars_file() if !-s 'ARS_table.txt';

	$include->{'CHROMOSOMES'}  = 1;
	$include->{'REFGEN_FILE'}  = 1;
	$include->{'BEDTOOLS'}     = 1;
	$include->{'ARS_FILE'}     = 1;
	$include->{'S_READS_CF'}   = 1;
	$include->{'W_READS_CF'}   = 1;
}

sub _require_n_group_options
{
	my $options     = shift;
	my $include     = shift;
	$include->{'n'} = 1;

	_require_file( $options, 'DISANNO_FILE' );
	_require_file( $options, 'GENANNO_FILE' );
	$include->{'DISANNO_FILE'} = 1;
	$include->{'GENANNO_FILE'} = 1;
}

1;

#-------------------------------------------------------------------------------
package SRA;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $sra_id    = $arguments{'sra_id'}     or
		die "ERROR: Please provide an argument for 'srr_id'\n";
    my $outDir    = $arguments{'outDir'}    or
		die "ERROR: Please provide an argument for 'outDir'\n";
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";

	my $sraFile   = "$outDir/$sra_id.sra";

	# Constructor
	my $self = SUPER::new $class
	(
	 	file   => $sraFile,
		outDir => $outDir,
	);
	$self->{'sra_id'} = $sra_id; # srr_id
	$self->{'config'} = $Config;
	bless( $self, $class );

	return $self;
}

sub destroy
{
	my $self = shift;
	my $file = $self->{'file'};

	print STDOUT "  Removing SRA files\n";
	`rm -f "$file"`;

	return 1;
}

sub get_srr_id
{
	my $self = shift;
	return $self->{'srr_id'};
}

sub download
{
	my $self    = shift;
	my $sraFile = $self->get_file;
	my $base    = $self->get_base;
	my $outDir  = $self->get_outDir;
	my $srr     = $self->{'sra_id'};
	my $config  = $self->{'config'};

	print STDOUT "  Downloading ...\n";
	my $time0   = time;

	# Download SRA file if incomplete or does not exist
	my $logFile = "$outDir/$base\_ncbi.log";
	my $srr3    = substr( $srr, 0, 3 );
	my $srr6    = substr( $srr, 0, 6 );
	my $ftpSite = "ftp://ftp-trace.ncbi.nlm.nih.gov/sra/sra-instant/reads/ByRun/sra/$srr3/$srr6/$srr/$srr.sra";
	`wget -t 10 -P $outDir -c $ftpSite > $logFile 2>&1`;

	if( !-s $sraFile ){
		print STDOUT "    Failed to download!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

1;

#-------------------------------------------------------------------------------
package FASTQ;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $outDir    = $arguments{'outDir'} or
		die "ERROR: Please provide an argument for 'outDir'\n";
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";

	# Constructor
	my $self = SUPER::new $class
	(
		file   => 'unavailable',
		outDir => $outDir,
	);
	$self->{'config'} = $Config;
	$self->{'file1'}  = undef;
	$self->{'file2'}  = undef;
	bless( $self, $class );

	return $self;
}

sub destroy
{
	my $self  = shift;
	my $file1 = $self->get_file1;
	my $file2 = $self->get_file2;

	print STDOUT "  Removing FASTQ files\n";

	`rm -f $file1`;
	`rm -f $file2` if $file2;

	return 1;
}

sub get_file1
{
	my $self = shift;
	return $self->{'file1'} || 0;
}

sub get_file2
{
	my $self = shift;
	return $self->{'file2'} || 0;
}

sub set_file1
{
	my $self = shift;
	my $file = shift;
	$self->{'file1'} = $file;

	return 1;
}

sub set_file2
{
	my $self = shift;
	my $file = shift;
	$self->{'file2'} = $file;

	return 1;
}

sub quality_control
{
	my $self   = shift;
	my $fastqc = $Config->get_value('FASTQC');
	my $outDir = $self->{'outDir'};
	print STDOUT "  Performing quality control ...\n";
	my $time0  = time;

	my $fastq1 = $self->{'file1'};
	my $base   = $fastq1;
	$base      =~ s/^.*\///;
	$base      =~ s/(.*).f(ast)*q(.gz)*/$1/;
	my $base2  = $base;
	$base2     =~ s/\.*$//;
	$base      =~ s/(.*)_read[12]/$1/;
	$base      =~ s/(.*)_[12]/$1/;
	my $qcLog  = "$outDir/$base\_fastqc.log";

	my $qcDir  = "$outDir/fastqc";
	`mkdir -p $qcDir`;
	print STDOUT "  > $fastq1\n";
	`fastqc --extract -o $qcDir -f fastq $fastq1 2> /dev/null`;
	my $num = `ls $qcDir/$base2*_fastqc/summary.txt | wc -l 2> /dev/null`;

	if( !$num ){
		print STDOUT "    Failed QC!\n";
		return 0;
	}
	my $qcOut1 = `cut -f1,2 $qcDir/$base2*_fastqc/summary.txt 2> /dev/null | sed 's|^|    |'`;
	print STDOUT "$qcOut1";

	# Save to log file
	`echo $fastq1 > $qcLog && cat $qcDir/$base2*_fastqc/summary.txt >> $qcLog`;

	if( $self->{'file2'} ){
		my $fastq2 = $self->{'file2'};
		my $base   = $fastq2;
		$base      =~ s/^.*\///;
		$base      =~ s/(.*).f(ast)*q(.gz)*/$1/;
		my $base2  = $base;
		$base2     =~ s/\.*$//;
		$base      =~ s/(.*)_read[12]/$1/;
		$base      =~ s/(.*)_[12]/$1/;
		print STDOUT "  > $fastq2\n";
		`fastqc --extract -o $qcDir -f fastq $fastq2 2> /dev/null`;
		my $num = `ls $qcDir/$base2*_fastqc/summary.txt | wc -l 2> /dev/null`;

		if( !$num ){
			print STDOUT "    Failed QC on paired reads!\n";
			return 0;
		}
		my $qcOut2 = `cut -f1,2 $qcDir/$base2*_fastqc/summary.txt 2> /dev/null | sed 's|^|    |'`;
		print STDOUT "$qcOut2";

		# Save to log file
		`echo $fastq2 >> $qcLog && cat $qcDir/$base2*_fastqc/summary.txt >> $qcLog`;
	}
	# Remove fastqc directory
	`rm -rf $qcDir`;

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub generate
{
	my $self      = shift;
	my $sraFile   = shift;
	my $outDir    = $self->get_outDir;
	my $Config    = $self->{'config'};
	my $fastqDump = $Config->get_value('FASTQDUMP');
	my $numFiles  = 0;

	print STDOUT "  Generating with --split-files option ...\n";
	my $time0   = time;

	my $fastq1  = $sraFile;
	$fastq1     =~ s/.sra$/_1.fastq/;
	$fastq1     =~ s/^.*\//$outDir\//;
	my $fastq2  = $sraFile;
	$fastq2     =~ s/.sra$/_2.fastq/;
	$fastq2     =~ s/^.*\//$outDir\//;

	# Get FASTQ files
	if( !-s $fastq1 ){
		`$fastqDump --split-files $sraFile -O $outDir 2> /dev/null`;
	}

	# Check for validity of FASTQ sequences after splitting
	my $status1 = check_fastq_file( $fastq1 );
	die "ERROR: Invalid FASTQ file 1\n"
		if !$status1;
	my $status2 = check_fastq_file( $fastq2 );

	if( $status2 == 2 ){
		`rm -f $fastq1 $fastq2 2> /dev/null`;
		print STDOUT "  Trying again without --split-files option ...\n";
		# Get FASTQ files
		`$fastqDump $sraFile -O $outDir 2> /dev/null`;
	}

	$numFiles = `ls $outDir/*.fastq 2> /dev/null | wc -l`;
	chomp $numFiles;

	if( $numFiles == 0 ){
		die "  Failed generating FASTQ files!\n";
	}
	$self->load_files( $fastq1, $fastq2 );

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub load_files
{
	my $self   = shift;
	my $fastq1 = shift;
	my $fastq2 = shift;
	my $outDir = $self->get_outDir;

	$self->{'file1'} = $fastq1;

	if( -s $fastq2 ){
		$self->{'file2'} = $fastq2;
	}

	return 1;
}

sub check_fastq_file
{
	my $file   = shift;
	my $cutoff = 20; # Minimum number of base pairs that would make for a valid sequence

	# Get full path from generated FASTQ files
	my $fastq  = `readlink -f $file 2> /dev/null`;
	chomp $fastq;

	if( -s $fastq ){
		my $base_count = `head -n2 $fastq | tail -n1 | wc -c`;
		chomp $base_count;

		if( $base_count > $cutoff ){
			return 1;
		}
		else{
			# FASTQ file exists, but it's not valid. Therefore, should not use --split-files option)
			return 2;
		}
	}
	else{
		return 0;
	}
}

1;

#-------------------------------------------------------------------------------
package ALIGNMENT;
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $bamFile   = $arguments{'bamFile'};
    my $Fastq     = $arguments{'fastq'};
    my $outDir    = $arguments{'outDir'}     or
		die "ERROR: Please provide an argument for 'outDir'\n";
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my $fastq1;
	my $fastq2;

	if( !$chroms ){
		_get_chroms_from_fa( $Config->get_value('REFGEN_FILE'), $Config );
		$chroms = $Config->get_value('CHROMOSOMES');
	}
	my $base;

	if( $bamFile ){
		$base = $bamFile;
		$base =~ s/^.*\///;
		$base =~ s/.bam$//;
	}
	else{
		$fastq1 = $Fastq->get_file1;
		$fastq2 = $Fastq->get_file2;
		$base   = $fastq1;
		$base   =~ s/^.*\///;
		$base   =~ s/(.*)_read[12]/$1/;
		$base   =~ s/(.*).f(ast)*q(.gz)*/$1/;
		$base   =~ s/(.*)_[12]/$1/;
	}

	# Get file names by chromosome
	my %chrFiles;

	for my $chr ( @$chroms ){
		$chrFiles{$chr} = "$outDir/$chr\_$base.bam";
	}

	# Constructor
	my $self = {
	 	file       => "$outDir/$base.bam",
	 	file1      => $fastq1,
	 	file2      => $fastq2,
		outDir     => $outDir,
		config     => $Config,
		chrFiles   => \%chrFiles,
		readLength => undef,
	};
	bless( $self, $class );

	return $self;
}

sub destroy_file
{
	my $self = shift;
	return 1;
}

sub destroy_files
{
	my $self  = shift;
	my $files = $self->{'chrFiles'};

	print STDOUT "  Removing BAM files split by chromosome\n";
	my @files = values %$files;
	`rm -f @files`;

	return 1;
}

sub get_readLength
{
	my $self = shift;
	return $self->{'readLength'};
}

sub get_file
{
	my $self = shift;
	return $self->{'file'};
}

sub get_chr_files
{
	my $self = shift;
	return $self->{'chrFiles'};
}

sub _get_chroms_from_fa
{
	my $fa_file = shift;
	my $Config  = shift;
	my @chroms  = `grep "^>" $fa_file | grep -oP "chr[\\d\\w]+" | grep -v chrM | sort -Vu`;
	chomp @chroms;
	$Config->set_value( 'CHROMOSOMES', \@chroms );

	return 1;
}

sub align_to_genome
{
	my $self     = shift;
	my $fastq1   = $self->{'file1'};
	my $fastq2   = $self->{'file2'} || 0;
	my $bamFile  = $self->{'file'};
	my $base     = $bamFile;
	$base        =~ s/^.*\///;
	$base        =~ s/\.bam$//;

	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value('SAMTOOLS');
	my $genome   = $Config->get_value('REFGEN_FILE');
	my $outDir   = $Config->get_value('O');
	my $index    = $Config->get_value('X');
	my $rnaseq   = $Config->get_value('r');
	my $proc     = $Config->get_value('p');

	my $gVersion = $genome;
	$gVersion    =~ s/^.*\///;
	$gVersion    =~ s/\.fa.*$//;

	my $time0      = time;
	my $numAligned = 0;
	my $totalReads = 0;

	# Detect paired-end or single-end reads
	my $pe_flag = 0;
	if( $fastq2 ){
		$pe_flag = 1;
		print STDOUT "  Aligning paired-end reads to $gVersion\n";
	}
	else{
		print STDOUT "  Aligning single-end reads to $gVersion\n";
	}

	# Check for gzipped files
	my $gz_flag = 0;
	if( $fastq1 =~ /\.gz/ ){
		print STDOUT "    FASTQ files are compressed\n";
		$gz_flag = 1;
	}

	# Use STAR with RNA-seq alignment (memory intensive! >32GB)
	if( $Config->get_value('s') ){
		my $star      = $Config->get_value('STAR');
		my $modifiers = "--outSAMtype BAM Unsorted --quantMode GeneCounts --outSAMmultNmax 1 --outMultimapperOrder Random";
		$modifiers   .= " --readFilesCommand zcat" if $gz_flag;
	 	my $out_base  = "--outFileNamePrefix $outDir/";
		my $fastqs    = $fastq1;
		$fastqs      .= " $fastq2" if $pe_flag;

		# Run STAR aligner
		`$star --runThreadN $proc $modifiers $out_base --genomeDir $index --readFilesIn $fastqs 2> /dev/null`;
		$totalReads  = `grep "Number of input reads"        $outDir/Log.final.out | cut -f2`; chomp $totalReads;
		$numAligned  = `grep "Uniquely mapped reads number" $outDir/Log.final.out | cut -f2`; chomp $numAligned;

		# Rename BAM file
		`mv -f $outDir/Aligned.out.bam $bamFile 2> /dev/null`;

		# Save relevant STAR output files
		`mv -f $outDir/Log.final.out $outDir/$base\_star.log 2> /dev/null`;
		`rm -rf $outDir/*.tab $outDir/_STARtmp $outDir/*.out 2> /dev/null`;
	}
	# Use HISAT2 to align RNA-seq
	elsif( $Config->get_value('t') ){
		my $hisat2    = $Config->get_value('HISAT2');
		my $log_file  = "$outDir/$base\_hisat2.log";
		my $modifiers = "--no-unal";
		my $fastqs    = "-U $fastq1";

		if( $pe_flag ){
			$modifiers .= " --no-discordant --no-mixed";
			$fastqs     = "-1 $fastq1 -2 $fastq2";
		}

		# Run HISAT2 aligner
		if( !-s $bamFile ){
			`$hisat2 -p $proc $modifiers -x $index $fastqs 2> $log_file | $samtools view -bS - > $bamFile 2> /dev/null`;
			$totalReads = `head -n1 $log_file | sed 's|^ *||' | cut -d' ' -f1`; chomp $totalReads;
			$numAligned = `grep -A1 "exactly" $log_file | sed 's|^ *||' | cut -d' ' -f1 | paste -sd+ | bc`; chomp $numAligned;
		}
		else{
			$totalReads = `head -n1 $log_file | sed 's|^ *||' | cut -d' ' -f1`; chomp $totalReads;
			$numAligned = `grep -A1 "exactly" $log_file | sed 's|^ *||' | cut -d' ' -f1 | paste -sd+ | bc`; chomp $numAligned;
		}
	}
	# Align with BOWTIE2
	else{
		my $bowtie2   = $Config->get_value('BOWTIE2');
		my $log_file  = "$outDir/$base\_bowtie2.log";

		my $modifiers = "--no-unal";
		my $fastqs    = "-U $fastq1";

		if( $pe_flag ){
			$modifiers .= " --no-discordant --no-mixed";
			$fastqs     = "-1 $fastq1 -2 $fastq2";
		}

		# Run BOWTIE2 aligner
		if( !-s $bamFile ){
			`$bowtie2 -p $proc $modifiers -x $index $fastqs 2> $log_file | $samtools view -bS - > $bamFile 2> /dev/null`;
			$totalReads = `head -n1 $log_file | sed 's|^ *||' | cut -d' ' -f1`; chomp $totalReads;
			$numAligned = `grep -A1 "exactly" $log_file | sed 's|^ *||' | cut -d' ' -f1 | paste -sd+ | bc`; chomp $numAligned;
		}
		else{
			$totalReads = `head -n1 $log_file | sed 's|^ *||' | cut -d' ' -f1`; chomp $totalReads;
			$numAligned = `grep -A1 "exactly" $log_file | sed 's|^ *||' | cut -d' ' -f1 | paste -sd+ | bc`; chomp $numAligned;
		}
	}

	if( $numAligned ){
		my $perc_aligned   = sprintf( "%.1f", $numAligned / $totalReads * 100 );
		print STDOUT "    Aligned reads = $numAligned ($perc_aligned%)\n";
		$self->{'aligned'} = $numAligned;
		$self->{'file'}    = $bamFile;
	}
	else{
		die "ERROR: Failed aligning reads\n";
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _count_aligned_reads
{
	my $bamFile    = shift;
	my $Config     = shift;
	my $samtools   = $Config->get_value('SAMTOOLS');
	my $numAligned = 0;

	$numAligned    = `$samtools view $bamFile | wc -l`;
	chomp $numAligned;

	return $numAligned;
}

sub sort_bam
{
	my $self     = shift;
	my $dupsFlag = shift;
	my $bamFile  = $self->{'file'};
	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value( 'SAMTOOLS' );

	# Skip this step if already performed
	return 1 if $dupsFlag;

	print STDOUT "  Sorting BAM file ...\n";

	# Check if BAM file is sorted
	my $out = `$samtools view -H $bamFile | grep -oP "SO:\\w+"`;
	if( $out !~ /unsorted/ ){
		print STDOUT "    BAM file is sorted\n";
		return 1;
	}
	my $time0   = time;

	`$samtools sort $bamFile $bamFile.sort > /dev/null 2>&1`;
	print STDOUT "    Failed to sort BAM file!\n" if !-s "$bamFile.sort.bam";

	`mv $bamFile.sort.bam $bamFile`;

	if( !$self->{'aligned'} ){
		my $numAligned     = _count_aligned_reads( $bamFile, $Config );
		$self->{'aligned'} = $numAligned;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub index_bam
{
	my $self     = shift;
	my $bamFile  = $self->{'file'};
	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value( 'SAMTOOLS' );

	print STDOUT "  Indexing BAM file $bamFile\n";
	my $time0    = time;

	if( !-s "$bamFile.bai" ){
		# Indexing
		`$samtools index $bamFile > /dev/null 2>&1`;
	}

	if( !-s "$bamFile.bai" ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub remove_duplicates
{
	my $self     = shift;
	my $bamFile  = $self->{'file'};
	my $readLen  = $self->{'readLength'};
	my $outDir   = $self->{'outDir'};
	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value('SAMTOOLS');

	print STDOUT "  Removing duplicate reads ...\n";

	# Check if BAM file is sorted
	my $out = `$samtools view -H $bamFile | grep -oP "SO:\\w+"`;
	if( ! $out or $out =~ /unsorted/ ){
		print STDOUT "    Sorting BAM file\n";
		`$samtools sort $bamFile $bamFile.sorted 2> /dev/null`;
		`mv -f $bamFile.sorted.bam $bamFile 2> /dev/null`;
	}
	my $time0   = time;

	# Remove duplicate reads by chromosome, position and sequence
	my(
	 	$reads,
		$dups,
		$percDup,
	) = _remove_duplicate_reads( $bamFile, $Config );
	die "    Failed!\n" if !$reads;

	my $perc    = sprintf( "%u", 100 - $percDup * 100 );
	my $dReads  = $reads - $dups;
	print STDOUT "    Unique reads returned = $dReads ($perc%)\n";
	$self->{'aligned_filt'} = $dReads;

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _remove_duplicate_reads
{
	my $bamFile = shift;
	my $Config  = shift;
	my $picard  = $Config->get_value('PICARD');
	my $bamBase = $bamFile;
	$bamBase    =~ s/\.bam$//;

	`$picard I=$bamFile REMOVE_DUPLICATES=true O=$bamBase\_dedup.bam M=$bamBase\_picard.log 2> /dev/null`;
	die "    Failed!\n" if !-s "$bamBase\_dedup.bam";
	`mv -f $bamBase\_dedup.bam $bamFile 2> /dev/null`;

	my $result = `grep -A1 "^LIBRARY" $bamBase\_picard.log | tail -1 | cut -f2,3,5,6,8`;
	chomp $result;

	# dups: number of single duplicate reads; pDups: number of paired duplicate reads
	my(
	 	$reads,
		$pReads,
		$dups,
		$pDups,
		$percDup,
	) = split( "\t", $result );

	if( $reads == 0 ){
		$reads = $pReads;
		$dups  = $pDups;
	}

	return(
	 	$reads,
		$dups,
		$percDup,
	);
}

sub get_length_of_largest_read
{
	my $self     = shift;
	my $bamFile  = $self->{'file'};
	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value('SAMTOOLS');

	# Get length of largest read
	print STDOUT "  Getting largest read length\n";

	my $readLength = `$samtools view $bamFile | head -n100000 | cut -f6 | grep -oP "^\\d+" | sort -nru | head -n1`;
	chomp $readLength;

	if( !$readLength ){
		print STDOUT "\n    Failed retrieving read length!\n";
		return 0;
	}
	$self->{'readLength'} = $readLength;

	print STDOUT "    Read length = $readLength bp\n";
	return 1;
}

sub split_bam_by_chr
{
	my $self     = shift;
	my $bamFile  = $self->{'file'};
	my $outDir   = $self->{'outDir'};
	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value('SAMTOOLS');
	my $chroms   = $Config->get_value('CHROMOSOMES');
	my $base     = $bamFile;
	$base        =~ s/^.*\///;
	$base        =~ s/\.bam$//;
	my %chrFiles;

	print STDOUT "  Split BAM file by chromosomes ...\n";
	my $time0    = time;

	# Indexing
	print STDOUT "    Indexing BAM file\n";
	`rm -f $bamFile.bai`;
	`$samtools index $bamFile > /dev/null 2>&1`;

	# Check if BAM file is sorted
	my $out = `$samtools view -H $bamFile | grep -oP "SO:\\w+"`;

	if( $out =~ /unsorted/ ){
		print STDOUT "    Sorting BAM file\n";
		`$samtools sort $bamFile $bamFile.sorted 2> /dev/null`;
		`mv -f $bamFile.sorted.bam $bamFile 2> /dev/null`;
	}

	for my $chr ( @$chroms ){
		my $chrBamFile = "$outDir/$chr\_$base.bam";

		# Split BAM file
		`$samtools view $bamFile $chr -b > $chrBamFile 2> /dev/null`
			if !-s $chrBamFile;

		# Count number of reads in this chromosome
		my $num_reads = _count_aligned_reads( $chrBamFile, $Config );
		my $answer    = "    No reads aligned to $chr\n";

		if( $num_reads ){
			$answer = "    Number of reads in $chr = $num_reads\n";
			$chrFiles{$chr} = $chrBamFile;
		}
		else{
			`rm -f $chrBamFile`;
		}
		print STDOUT $answer;
	}

	if( keys %chrFiles ){
		my $time1   = time;
		my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
		print STDOUT "  Time elapsed: $elapsed min\n";
		$self->{'chrFiles'} = \%chrFiles;

		return 1;
	}
	else{
		print STDOUT "  Failed splitting BAM file!\n";
		return 0;
	}
}

sub _get_chroms_from_bam
{
	my $bamFile  = shift;
	my $Config   = shift;
	my $samtools = $Config->get_value('SAMTOOLS');
	my @chroms   = `$samtools view -H $bamFile | grep "^\@SQ" | grep -v chrM | cut -f2 | cut -d: -f2`;
	chomp @chroms;
	$Config->set_value( 'CHROMOSOMES', \@chroms );

	return 1;
}

1;

#-------------------------------------------------------------------------------
package PEAKS;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $bamFile   = $arguments{'bamFile'} or
		die "ERROR: Please provide an argument for 'bamFile'\n";
    my $outDir    = $arguments{'outDir'}  or
		die "ERROR: Please provide an argument for 'outDir'\n";
    my $Config    = $arguments{'config'}  or
		die "ERROR: Please provide an argument for 'config'\n";
	my $chroms    = $Config->get_value('CHROMOSOMES');

	my $base      = $bamFile;
	$base         =~ s/^.*\///;
	$base         =~ s/.bam$//;
	my $peakFile  = "$outDir/$base.bed";

	my %chrFiles;

	for my $chr ( @$chroms ){
		$chrFiles{$chr} = "$outDir/$chr\_$base.bed";
	}

	# Constructor
	my $self = SUPER::new $class(
	 	file   => $peakFile,
		outDir => $outDir,
	);
	$self->{'config'} = $Config;
	$self->{'chrFiles'}  = \%chrFiles;
	$self->{'bamFile'}   = $bamFile;
	bless( $self, $class );

	return $self;
}

sub destroy_file
{
	my $self = shift;
	my $file = $self->{'file'};

	print STDOUT "  Removing PEAK file\n";
	`rm -f $file`;

	return 1;
}

sub destroy_files
{
	my $self  = shift;
	my $files = $self->{'chrFiles'};

	print STDOUT "  Removing PEAK files split by chromosome\n";
	my @files = values %$files;
	`rm -f @files`;

	return 1;
}

sub get_chr_files
{
	my $self = shift;
	return $self->{'chrFiles'};
}

sub call_peaks
{
	my $self     = shift;
	my $bamFile  = $self->{'bamFile'};
	my $peakFile = $self->get_file;
	my $peakBase = $self->get_base;
	my $outDir   = $self->get_outDir;

	my $Config   = $self->{'config'};
	my $chroms   = $Config->get_value('CHROMOSOMES');
	my $proc     = $Config->get_value('p');
	my $macs2    = $Config->get_value('MACS2');
	my $extend   = $Config->get_value('PEAK_EXT');

	print STDOUT "  Calling peaks ...\n";
	my $time0    = time;

	# Call peaks only on nodup BAM file using MACS2
	if( !-s $peakFile ){
		`$macs2 callpeak -t $bamFile -f BAM -g hs -n $outDir/$peakBase -B -q 0.01 2>/dev/null`;

		my $np_file = "$outDir/$peakBase\_peaks.narrowPeak";

		# MACS2 unable to build peak model due to few reads in the BAM file
		# Run alternative, --nomodel, calculation
		if( !-s $np_file ){
			`$macs2 callpeak --nomodel --extsize 147 -t $bamFile -f BAM -g hs -n $outDir/$peakBase -B -q 0.01 2>/dev/null`;
		}

		# Rename peakFile
		if( -s $np_file ){
			`mv -f $np_file $peakFile`;
			`rm -f $outDir/$peakBase*.bdg $outDir/$peakBase\_model.r $outDir/$peakBase\_peaks.xls $outDir/$peakBase\_summits.bed`;
		}
		else{
			# Total failure of peak caller MACS2
			print STDOUT "    Failed to call peaks!\n";
			return 0;
		}

		# Modify a few things in the BED file and delete unused files
		# Eliminate path in BED file so it takes less space in disk
		`sed -i 's|$outDir/$peakBase\_||' $peakFile`;

		# Extend peaks by $extend bp on both sides
		`awk '{print \$1,\$2-$extend,\$3+$extend,\$4,\$5+$extend}' OFS='\\t' $peakFile > $peakFile.tmp`;
		`mv $peakFile.tmp $peakFile`;
	}

	# Report number of peaks (if any)
	my $numPeaks = _get_number_of_peaks( $peakFile );
	my $answer   = "    No peaks found!\n";
	$answer      = "    Total number of peaks = $numPeaks\n" if $numPeaks;
	print STDOUT $answer;

	my $time1    = time;
	my $elapsed  = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return $numPeaks;
}

sub split_peaks_by_chr
{
	my $self     = shift;
	my $peakFile = $self->get_file;
	my $peakBase = $self->get_base;
	my $outDir   = $self->get_outDir;
	my $Config   = $self->{'config'};
	my $chroms   = $Config->get_value('CHROMOSOMES');
	my %chrFiles;

	print STDOUT "  Splitting peak file by chromosomes ...\n";
	my $time0 = time;

	if( !-s $peakFile ){
		print STDOUT "    No peak file found!\n";
		return 0;
	}

	# Split PEAK file by chromosomes
	for my $chr ( @$chroms ){
		my $chrPeakFile = "$outDir/$chr\_$peakBase.bed";

		`grep -P "^$chr\\t" $peakFile > $chrPeakFile`;

		my $numPeaks = _get_number_of_peaks( $chrPeakFile );
		my $answer   = "    No peaks found for $chr\n";

		if( $numPeaks ){
			$answer = "    Number of peaks in $chr = $numPeaks\n";
			$chrFiles{$chr} = $chrPeakFile;
		}
		else{
			`rm -f $chrPeakFile`;
		}
		print STDOUT $answer;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed = $elapsed min\n";

	if( keys %chrFiles ){
		$self->{'chrFiles'} = \%chrFiles;
		return 1;
	}
	else{
		print STDOUT "    No chromosome peak files were found!\n";
		return 0;
	}
}

sub _get_number_of_peaks
{
	my $peakFile = shift;
	my $numPeaks = 0;

	if( -s $peakFile ){
		$numPeaks = `cat $peakFile | wc -l`;
		chomp $numPeaks;
	}

	return $numPeaks;
}

sub count_reads_under_peak
{
	my $self      = shift;
	my $bamFiles  = shift;
	my $peakFile  = $self->get_file;
	my $peakFiles = $self->get_chr_files;
	my $peakBase  = $self->get_base;
	my $outDir    = $self->get_outDir;

	my $Config    = $self->{'config'};
	my $extend    = $Config->get_value('PEAK_EXT');
	my $minRpkm   = $Config->get_value('PEAK_RPKM');
	my $minWidth  = $Config->get_value('PEAK_WIDTH');
	my $samtools  = $Config->get_value('SAMTOOLS');
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my $proc      = $Config->get_value('p');

	print STDOUT "  Counting reads under called peaks ...\n";
	my $time0     = time;

	my $pm = new Parallel::ForkManager( $proc );

	for my $chr ( @$chroms ){
		$pm->start and next;

		if( $peakFiles->{$chr} ){
			my $chrPeakFile  = $peakFiles->{$chr};
			my $chrBamFile   = $bamFiles->{$chr};
			my $chrCountFile = "$chrPeakFile.count";

			open( PEAK, "$chrPeakFile" ) or
				die "ERROR: Could not open file $chrPeakFile";
			open( BAM, "$samtools view $chrBamFile |" ) or
				die "ERROR: Could not open file $chrBamFile\n";
			open( OUT, ">$chrCountFile" ) or
				die "ERROR: Could not open file $chrCountFile\n";

			while( my $peak_line = <PEAK> ){
				chomp $peak_line;
				my(
					$p_chr,
					$p_start,
					$p_end,
					$p_id,
					$p_summit,
				) = split( "\t", $peak_line );
				$p_summit = ( $p_end - $p_start ) / 2 + $p_start;
				my $read_count;
				my $state = 0;

				do{
					my $bam_line = <BAM>;

					if( $bam_line ){
						chomp $bam_line;
						# SRR873824.24745869  0   chr22   16051210
						my @split   = split( "\t", $bam_line );

						# Filter by CIGAR line (exclude rare alignments)
						my $cigar   = $split[5];
						next if $cigar !~ /^(\d+[MSHIND])+$/;

						my $r_chr   = $split[2];
						my $r_start = $split[3];
						my $r_seq   = $split[9];
						my $r_len   = length $r_seq;
						my $r_end   = $r_start + $r_len - 1;

						if( $r_end >= $p_start ){
							if( $r_end >= $p_start and $r_start <= $p_end ){
								$read_count++;
							}
							else{
								my @p_data = (
									$p_chr,
									$p_start,
									$p_end,
									$p_id,
									$p_summit,
								);

								# CHR PEAK_START PEAK_END PEAK_ID PEAK_SUMMIT READ_COUNT
								if( $read_count ){
									print OUT join( "\t", @p_data ), "\t$read_count\n";
								}

								# Last peak considered if there is no more reads in the BAM file
								last if eof BAM;

								# Done with this peak, go to the next
								next;
							}
						}
					}
					else{
						$state = 1;
					}
				}
				until( $state == 1 );
			}
			close BAM;
			close PEAK;
			close OUT;

			# Rename the modified file
			if( -s $chrCountFile ){
				`mv $chrCountFile $chrPeakFile`;
			}
			else{
				print STDOUT "    Peak file for chromosome $chr not generated!\n";
			}
		}
		$pm->finish;
	}
	$pm->wait_all_children;
	my %chrFiles;

	# Count number of peaks in generated files
	for my $chr ( @$chroms ){

		if( $peakFiles->{$chr} ){

			if( -s $peakFiles->{$chr} ){
				my $chrPeakFile = $peakFiles->{$chr};
				my $rCount      = `cut -f6 $chrPeakFile | wc -l`; chomp $rCount;

				if( $rCount ){
					print STDOUT "    Number of counted peaks in $chr = $rCount\n";
					$chrFiles{$chr} = $chrPeakFile;
				}
				else{
					print STDOUT "    No counted peaks in $chr\n";
				}
			}
		}
	}

	if( ! keys %chrFiles ){
		print STDOUT "    Failed!\n";
		return 0;
	}
	$self->{'chrFiles'} = \%chrFiles;

	# Concatenate and sort BED files
	`cat $outDir/chr*_$peakBase.bed | cut -f1-6 | sort -Vk1,1 -k2,2g > $peakFile`;

	# Remove spurious peaks (>= 300 bp in width AND >= 0.4 RPKM)
	my $totalCount = `cut -f6 $peakFile | paste -sd+ | bc`; chomp $totalCount;
	$minWidth     += 2 * $extend;
	`awk '{print \$0,\$3-\$2,\$6/(\$3-\$2)*1000000/$totalCount}' OFS='\\t' $peakFile | awk '{if(\$8>=$minRpkm && \$7>=$minWidth) print \$0}' | sort -Vk1,1 -k2,2n > $peakFile.tmp`;
	`mv -f $peakFile.tmp $peakFile`;

	# Report on the total number of reads in all peaks
	print STDOUT "    Total number of reads in peaks = $totalCount\n";

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

1;

#-------------------------------------------------------------------------------
package GENOTYPING;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $outDir    = $arguments{'outDir'} or
		die "ERROR: Please provide an argument for 'outDir'\n";
	my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my $gen_path  = $Config->get_value('GENOT_PATH');

	# Constructor
	my $self = SUPER::new $class
	(
	 	file   => "noFile",
		outDir => $outDir,
	);
	$self->{'config'}   = $Config;
	$self->{'chrFiles'} = undef;
	$self->{'filtered'} = undef;
	bless( $self, $class );

	return $self;
}

sub destroy_file
{
	my $self = shift;
	my $file = $self->get_file;

	print STDOUT "  Removing GENOTYPE file\n";
	`rm -f $file`;

	return 1;
}

sub destroy_files
{
	my $self  = shift;
	my $files = $self->{'chrFiles'};

	print STDOUT "  Removing temporary GENOTYPE files\n";
	my @files = values %$files;
	`rm -f @files`;

	return 1;
}

sub get_chr_files
{
	my $self = shift;
	return $self->{'chrFiles'} || 0;
}

sub get_filtered_files
{
	my $self = shift;
	return $self->{'filtered'};
}

sub load_file
{
	my $self    = shift;
	my $genFile = shift;
	my $Config  = $self->{'config'};

	print STDOUT "  Extracting GENOTYPE information ...\n";
	my $time0   = time;

	die "    Genotyping file not present or empty\n    $genFile\n"
		if !-s $genFile;

	my $numHets = `cat $genFile | wc -l`;
	chomp $numHets;

	if( $numHets ){
		print STDOUT "    Number of het-SNPs = $numHets\n";
	}
	else{
		die "    Failed retrieving het-SNPs\n";
	}
	$self->set_file( $genFile );

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub split_gen_by_chr
{
	my $self    = shift;
	my $genFile = $self->get_file;
	my $genBase = $self->get_base;
	my $outDir  = $self->get_outDir;
	my $Config  = $self->{'config'};
	my $chroms  = $Config->get_value('CHROMOSOMES');
	my %chrFiles;

	print STDOUT "  Splitting GENOTYPE file into chromosomes ...\n";
	my $time0   = time;

	for my $chr ( @$chroms ){
		my $chrGenFile = "$outDir/$chr\_$genBase.gen";

		if( $genFile =~ /gz$/ ){
			`zgrep -P "^$chr\t" $genFile > $chrGenFile`;
		}
		else{
			`grep -P "^$chr\t" $genFile > $chrGenFile`;
		}
		my $numHets = `cat $chrGenFile | wc -l`;
		chomp $numHets;

		if( $numHets ){
			print STDOUT "    Number of heterozygous positions in $chr = $numHets\n";
			$chrFiles{$chr} = $chrGenFile;
		}
		else{
			print STDOUT "    No heterozygous positions in $chr\n";
			`rm -f $chrGenFile`;
		}
	}

	if( ! keys %chrFiles ){
		print STDOUT "    Failed splitting genotyping file!\n";
		return 0;
	}
	$self->{'chrFiles'} = \%chrFiles;

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _get_chroms_from_gen
{
	my $genFile = shift;
	my $Config  = shift;
	my @chroms  = `cut -f1 $genFile | sort -Vu`;
	chomp @chroms;
	$Config->set_value( 'CHROMOSOMES', \@chroms );

	return 1;
}

sub filter
{
	my $self     = shift;
	my $bedFile  = shift;
	my $genFile  = $self->get_file;
	my $outDir   = $self->get_outDir;

	my $Config   = $self->{'config'};
	my $chroms   = $Config->get_value('CHROMOSOMES');
	my $bedtools = $Config->get_value('BEDTOOLS');

	my $base  = $bedFile;
	$base     =~ s/^.*\///;
	$base     =~ s/.bed$//;
	my $time0 = time;

	print STDOUT "  Filtering GENOTYPE file ...\n";

	# Find SNPs within peaks
	my $tmpGen = "$outDir/filtered.gen";
	`$bedtools intersect -a $genFile -b $bedFile -wo | cut -f1-4 > $tmpGen`;
	$self->set_file( $tmpGen );

	my $numGen = `cat $tmpGen | wc -l`; chomp $numGen;
	if( $numGen ){
		print STDOUT "    Heterozygous positions within peaks = $numGen\n";
	}
	else{
		print STDOUT "    No heterozygous positions within called peaks\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

#-------------------------------------------------------------------------------
package ADB;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $adbFile   = $arguments{'file'};
    my $outDir    = $arguments{'outDir'}    or
		die "ERROR: Please provide an argument for 'outDir'\n";
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";

	# Constructor
	my $self = SUPER::new $class(
	 	file   => $adbFile,
		outDir => $outDir,
	);
	$self->{'config'} = $Config;
	bless( $self, $class );

	return $self;
}

sub destroy_files
{
	my $self    = shift;
	my $datFile = $self->{'datFile'};
	my $aliFile = $self->{'aliFile'};

	 print STDOUT "  Removing DAT and ALI files split by chromosome\n";
	`rm -f $datFile $aliFile`;

	return 1;
}

sub get_datFile
{
	my $self = shift;
	return $self->{'datFile'} || 0;
}

sub get_aliFile
{
	my $self = shift;
	return $self->{'aliFile'} || 0;
}

sub find_allelic_behavior
{
	my $self      = shift;
	my $Alignment = shift;
	my $genFiles  = shift;
	my $datFile   = $self->get_file;
	my $datBase   = $self->get_base;
	my $outDir    = $self->get_outDir;
	my $bamFiles  = $Alignment->get_chr_files;

	my $Config    = $self->{'config'};
	my $proc      = $Config->get_value('p');
	my $samtools  = $Config->get_value('SAMTOOLS');
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my $sReadsCf  = $Config->get_value('S_READS_CF');
	my $wReadsCf  = $Config->get_value('W_READS_CF');

	my @header = (
		'CHR',
		'START',
		'END',
		'S_BASE',
		'W_BASE',
		'S_READS',
		'W_READS',
		'WS_RATIO',
		'SNP_STATUS',
	);

	print STDOUT "  Finding ADBs ...\n";
	my $time0 = time;

	# Find ADBs
	my $pm = new Parallel::ForkManager( $proc );

	for my $chr ( @$chroms ){
		$pm->start and next;
		my $adbNum = 0;

		my $chrBamFile = $bamFiles->{$chr};
		open( BAM, "$samtools view $chrBamFile |" ) or
			die "ERROR: Could not open BAM file $chrBamFile\n";
		my $chr_datFile = "$outDir/$chr\_$datBase.dat";
		open( DAT, ">$chr_datFile" ) or
			die "ERROR: Could not create file $chr_datFile\n";

		# Load genotyping information
		my %genotype;
		if( defined $genFiles ){
			die "ERROR: Missing genotyping information for chromosome $chr\n"
				if !$genFiles->{$chr};

			my $g_file = $genFiles->{$chr};
			open( GEN, $g_file ) or
				die "ERROR: Could not open genotype file: $g_file\n";

			while( my $line = <GEN> ){
				chomp $line;
				my( $chr, $start, $end, $val ) = split( "\t", $line );
				my $imp = 'g';
				$imp    = 'i' if $val;
				$genotype{$start} = $imp;
			}
		}

		# Print header
		print DAT join( "\t", @header ), "\n";

=pod
		# BAM line column infomation
		0 SEQ_ID    SRR873824.24745869
		1 CODE      0
		2 CHR       chr22
		3 POS       16051210
		4 -
		5 CIGAR     36M
		6 -
		7 -
		8 -
		9 SEQUENCE  GTAAAATACTTTCATTTTCCTTCAGAGTCTGCTGTC
=cut

		# Process First BAM line
		my $bam_line    = <BAM>;
		my @bam         = split( "\t", $bam_line );
		my $start       = $bam[3];
		my @sorted_pos  = sort{ $a <=> $b } keys %genotype;
		my %pileups;

		while( my $gpos = shift @sorted_pos ){
			do{
				if( $gpos < $start ){
					# Write out results
					if( %pileups ){
						my $b_pileups = $pileups{$gpos};
						my @sorted    = sort{ $b_pileups->{$b} <=> $b_pileups->{$a} } keys %$b_pileups;
						my $s_base    = shift @sorted;
						my $sReads    = $b_pileups->{$s_base};

						if( $sReads >= $sReadsCf ){
							my $w_base  = shift @sorted         || 'N';
							my $wReads  = $b_pileups->{$w_base} ||  0;
							my $imp     = $genotype{$gpos};

							my $ws_ratio = $wReads / $sReads;
							print DAT "$chr\t$gpos\t$gpos\t$s_base\t$w_base\t$sReads\t$wReads\t$ws_ratio\t$imp\n";
						}
						undef %pileups;
					}
					next;
				}
				else{
					# Filter by CIGAR line (exclude rare alignments)
					if( $bam[5] =~ /^(\d+[MSHINDP])+$/ ){
						# Correct alternate sequence according to the CIGAR line
						my( $cseq, $clen ) = _correct_sequence( \@bam );
						my $end = $start + $clen - 1;

						if( $gpos <= $end ){
							# Get pileup
							my $base = substr( $cseq, $gpos - $start, 1 );
							$pileups{$gpos}{$base}++;
						}
					}
					# Process next BAM line
					$bam_line = <BAM>;
					@bam      = split( "\t", $bam_line );
					$start    = $bam[3];
				}
			}
			until( eof BAM );

			last if eof BAM;
		}
		close BAM;
		close DAT;

		# Remove chr BAM files (no longer used)
		`rm -f $chrBamFile 2> /dev/null`;

		$adbNum = `cat $chr_datFile | wc -l`;
		chomp $adbNum;
		$adbNum--; # Do not count the header
		print STDOUT "    Positions with ADB found for $chr = $adbNum\n";

		$pm->finish;
	}
	$pm->wait_all_children;

	# Print header on DAT file
	`head -n1 $outDir/chr*_$datBase.dat | grep -m1 "^CHR" > $datFile`;

	# Print body on DAT file
	`cat $outDir/chr*_$datBase.dat | grep -v "^CHR" | sort -Vk1,1 -k2,2n >> $datFile`;

	# Count total allelic binders there are in the DAT file
	my $numAllelic = `tail -n +2 $datFile | wc -l`;
	chomp $numAllelic;

	if( $numAllelic ){
		print STDOUT "    Total allelic binders = $numAllelic\n";
	}
	else{
		print STDOUT "    No allelic binders found!\n";
		`rm -f $datFile`;
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _write_results
{
	my $DAT      = shift;
	my $pileups  = shift;
	my $gen_pos  = shift;
	my $srCutoff = shift;
	my $wrCutoff = shift;

	for my $chr ( keys %$pileups ){
		my $pileups_pos = $pileups->{$chr};

		for my $pos ( keys %$pileups_pos ){
			my $pileups_base = $pileups_pos->{$pos};
			my @sorted       = sort{ $pileups_base->{$b} <=> $pileups_base->{$a} } keys %$pileups_base;

			if( $gen_pos and $gen_pos->{$pos} ){
				# Genotyping information is used
				# Therefore, positions are filtered by genotype
				my $s_base   = shift @sorted;
				my $sReads  = $pileups_base->{$s_base};
				next if $sReads < $srCutoff;

				my $w_base   = shift @sorted || 'N';
				my $wReads  = $pileups_base->{$w_base} || 0;
				my $imp      = $gen_pos->{$pos};

				my $ws_ratio = $wReads / $sReads;
				print $DAT "$chr\t$pos\t$pos\t$s_base\t$w_base\t$sReads\t$wReads\t$ws_ratio\t$imp\n";
			}
=pod
			else{
				# No genotyping information
				# All positions are reported, except those with $wReads < $wrCutoff
				next if keys %$pileups_base < 2; # 2 or more bases found (only interested in allelic behavior)

				my $s_base   = shift @sorted;
				my $sReads  = $pileups_base->{$s_base};
				my $w_base   = shift @sorted;
				my $wReads  = $pileups_base->{$w_base};
				my $imp      = 'p';
				next if "$s_base$w_base" =~ /-/; # No indels
				next if $wReads < $wrCutoff;

				my $ws_ratio = $wReads / $sReads;
				print $DAT "$chr\t$pos\t$s_base\t$w_base\t$sReads\t$wReads\t$ws_ratio\t$imp\n";
			}
=cut
		}
	}

	return 1;
}

sub _correct_sequence
{
=pod
	# BAM line column infomation
	0 SEQ_ID    SRR873824.24745869
	1 CODE      0
	2 CHR       chr22
	3 POS       16051210
	4 -
	5 CIGAR     36M
	6 -
	7 -
	8 -
	9 SEQUENCE  GTAAAATACTTTCATTTTCCTTCAGAGTCTGCTGTC
=cut
	my $bam   = shift;
	my $cigar = '' . $bam->[5];
	my $len   = length $bam->[9];
	my @num   = $cigar =~ /\d+/g;
	my @let   = $cigar =~ /\D/g;
	my $seq   = $bam->[9];

	# Relative position
	my $p = 0;
	my $clen;

	for( my $i = 0; $i < scalar @let; $i++ ){
		my $letter = $let[$i];
		my $number = $num[$i];

		if( $letter eq 'M' ){
			$p    += $number;
			$clen += $number;
		}
		elsif( $letter =~ /[SI]/ ){
			# Remove from sequence
			substr( $seq, $p, $number, '' );
		}
		elsif( $letter =~ /[NPD]/ ){
			# Insert '-'s
			my $m = '-' x $number;
			substr( $seq, $p, 0, $m );
			$p += $number;
		}
	}

	return( $seq, $clen );
}

1;

#-------------------------------------------------------------------------------
package ARS;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $arsFile   = $arguments{'file'}       or
		die "ERROR: Please provide an argument for 'file'\n";
    my $outDir    = $arguments{'outDir'}    or
		die "ERROR: Please provide an argument for 'outDir'\n";
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";

	# Constructor
	my $self = SUPER::new $class(
	 	file   => $arsFile,
		outDir => $outDir,
	);
	$self->{'ar_scores'} = undef;
	bless( $self, $class );

	# Load FDR data
	$self->_load_ars( $Config );

	return $self;
}

sub get_ars_data
{
	my $self = shift;
	return $self->{'ar_scores'};
}

sub _load_ars
{
	my $self    = shift;
	my $Config  = shift;
	my $arsFile = $self->get_file;
	my $IN      = $self->Open;

	# Remove header
	my $header = <$IN>;
	my %ars_data;

	while( my $line = <$IN> ){
		chomp $line;
		my(
		 	$exp,
		 	$ratio,
			$A,
			$B,
		) = split( "\t", $line );

		$ars_data{$exp}{$ratio} = [$A, $B];
	}
	$self->Close;
	$self->{'ar_scores'} = \%ars_data;

	return 1;
}

sub get_ars_score
{
	my $self  = shift;
	my $exp   = shift;
	my $ratio = shift;
	my $reads = shift;
	my $data  = $self->{'ar_scores'};
	my $step  = 0.1;
	my $ars;

	for( my $ratio0 = 0; $ratio0 <= 1; $ratio0 += $step ){
		my $ratio1 = sprintf( "%.2f", $ratio0 + $step );
		$ratio0    = sprintf( "%.2f", $ratio0 );

		if( $ratio >= $ratio0 && $ratio <= $ratio1 ){
			my $A0 = $data->{$exp}{$ratio0}[0];
			my $B0 = $data->{$exp}{$ratio0}[1];

			if( $ratio == $ratio0 ){
				$ars   = sprintf( "%.3f", $A0 / ( 1 + $B0 * $reads ) - $A0 );
			}
			elsif( $ratio == $ratio1 ){
				my $A1 = $data->{$exp}{$ratio1}[0];
				my $B1 = $data->{$exp}{$ratio1}[1];

				$ars   = sprintf( "%.3f", $A1 / ( 1 + $B1 * $reads ) - $A1 );
			}
			else{
				my $A1    = $data->{$exp}{$ratio1}[0];
				my $B1    = $data->{$exp}{$ratio1}[1];

				# Interpolate A and B values
				my $range = $ratio1 - $ratio0;
				my $diff  = $ratio  - $ratio0;
				my $A     = $A0 + ( $A1 - $A0 ) / $range * $diff;
				my $B     = $B0 + ( $B1 - $B0 ) / $range * $diff;

				# Apply logistic function with obtained config to get ARS
				$ars      = sprintf( "%.3f", $A / ( 1 + $B * $reads ) - $A );
			}
		}
	}

	return $ars;
}

1;

#-------------------------------------------------------------------------------
package STATISTICS;
use strict;
use warnings;
use POSIX qw(floor ceil);

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $data      = $arguments{'data'} or
		die "ERROR: Please provide an argument for 'data'\n";

	my $self = {
	 	data => $data,
		min  => undef,
		max  => undef,
	};
	bless( $self, $class );

	return $self;
}

sub min
{
	my $self = shift;
	my $data = $self->{'data'};
	
	if( $self->{'min'} ){
		return $self->{'min'};
	}
	else{
		my( $min, $max ) = _min_and_max( $data );
		$self->{'min'}   = $min;
		$self->{'max'}   = $max;
		return $min;
	}
}

sub max
{
	my $self = shift;
	my $data = $self->{'data'};
	
	if( $self->{'max'} ){
		return $self->{'max'};
	}
	else{
		my( $min, $max ) = _min_and_max( $data );
		$self->{'min'}   = $min;
		$self->{'max'}   = $max;
		return $max;
	}
}

## Calculates arithmetic mean given an array of numbers
#  Takes array reference
sub arithmetic_mean
{
	my $self = shift;
	my $data = $self->{'data'};
	my $mean = _mean( $data );
	return $mean;
}

# Minimum and maximum values
sub _min_and_max
{
	my $data = shift;

	# Sort values in ascending order
	my @sorted = sort{ $a <=> $b } @$data;
	my $min    = $sorted[0];
	my $max    = $sorted[-1];

	return( $min, $max );
}

sub _mean
{
	my $data = shift;
	my $n    = scalar @$data;
	my $sum  = 0;

	for my $value ( @$data ){
		$sum += $value;
	}
	return $sum / $n;
}

## Calculates standard deviation given an array of numbers and their mean
#  Takes array reference and mean
sub standard_deviation
{
	my $self = shift;
	my $data = $self->{'data'};
	my $mean = 0;

	if( $self->{'mean'} ){
		$mean = $self->{'mean'};
	}
	else{
		$mean = _mean( $data );
	}

	my $n   = scalar @$data;
	my $sum = 0;

	for my $value ( @$data ){
		my $sqdiff = ( $value - $mean ) ** 2;
		$sum    += $sqdiff;
	}

	my $stdev = sqrt( $sum / ( $n - 1 ) );

	return $stdev;
}

1;

#-------------------------------------------------------------------------------
package MOTIF;
use base 'FILE';
use warnings;
use strict;


sub new
{
    my $class     = shift;
    my %arguments = @_;
    my $file      = $arguments{'file'};
    my $outDir    = $arguments{'outDir'};
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";

	my $self = SUPER::new $class(
	 	file    => $file,
		outDir  => $outDir,
	);
    $self->{'motifMatrix'}    = undef; # Array of arrays defining the binding motif matrix
    $self->{'motif_length'}    = undef;
    $self->{'canonical_score'} = undef;
    $self->{'alphabet'}        = ['A','C','G','T'];
    bless( $self, $class );

	$self->_process_matrix_file;
    $self->_normalize;
	$self->_find_canonical_score( $Config );

    return $self;
}

sub get_canonical_score
{
	my $self = shift;
	return $self->{'canonical_score'};
}

sub _find_canonical_score
{
	my $self     = shift;
	my $Config   = shift;
	my $alphabet = $self->{'alphabet'};
	my $m_file   = $self->get_file;
	my $m_base   = $self->get_base;
	my $matrix   = $self->{'motifMatrix'};
	my $outDir   = $self->{'outDir'};
	my $fasta    = "$outDir/$m_base\_canonical.fa";

	# Find canonical sequence
	my $can_seq;

	for( my $j = 0; $j < scalar @{$matrix->[0]}; $j++ ){
		my $p_freq = 0;
		my $c_base; # Canonical base

		for( my $i = 0; $i < scalar @$alphabet; $i++ ){
			my $base = $alphabet->[$i];
			my $freq = $matrix->[$i][$j];

			if( $freq > $p_freq ){
				$c_base  = $base;
				$p_freq  = $freq;
			}
		}
		$can_seq .= $c_base;
	}
	open( OUT, ">$fasta" );
	print OUT  ">$m_base\n$can_seq\n";
	close OUT;

	# Find canonical score
	my $moods   = $Config->get_value( 'MOODS' );
	my $pval_cf = $Config->get_value( 'MOODS_PVAL' );

	# Create temporary matrix file without the first column that contains the bases
	my $cm_file = "$outDir/$m_base\_tmp.mat";
	`cut -d' ' -f2- "$m_file" > "$cm_file"`;

	# Run MOODS to get canonical score
	# MOODS produces zero-based positions in its output
	my $can_score = `$moods -f $pval_cf "$fasta" "$cm_file" 2>&1 | grep -vP \"^(cal|loa|Mat|Hit|Tot|\\n+)\" | awk \'NF\' | grep -P "^0\t" | cut -f2`;
	chomp $can_score;

	$self->{'canonical_score'} = $can_score;

	return 1;
}

sub get_motif_length
{
    my $self = shift;
    return $self->{'motif_length'};
}

sub get_forward_file
{
    my $self        = shift;
    my $motifMatrix = $self->{'motifMatrix'};
    my $outDir      = $self->{'outDir'};
    my $file_base   = $self->get_base;
	my $file_name   = "$outDir/$file_base\_fw.mat";

	my $Matfile = new FILE(
	 	file   => $file_name,
		outDir => $outDir,
	);

    _print_motifMatrix(
		$motifMatrix,
		$Matfile,
	);

    die "ERROR: Failed generating forward motif file $file_name\n" 
		if !-s "$file_name";

    return $Matfile->get_file;
}

sub get_reverse_file
{
    my $self        = shift;
    my $motifMatrix = $self->{'motifMatrix'};
    my $outDir      = $self->{'outDir'};
    my $file_base   = $self->get_base;
	my $file_name   = "$outDir/$file_base\_rc.mat";

    $motifMatrix    = _reverse_matrix( $motifMatrix );

	my $Matfile = new FILE(
	 	file    => $file_name,
		outDir  => $outDir,
	);

    _print_motifMatrix(
		$motifMatrix,
		$Matfile,
	);

    die "ERROR: Failed generating reverse motif file $file_name\n" 
		if !-s "$file_name";

    return $Matfile->get_file;
}

sub _reverse_matrix
{
    my $matrix = shift;
	my $width  = scalar @$matrix;
	my @rc_matrix;

    for( my $i = $width - 1; $i >= 0; $i-- ){
        my @frequencies = reverse @{$matrix->[$i]};
        push( @rc_matrix, \@frequencies );
    }

	return \@rc_matrix;
}

sub _print_motifMatrix
{
    my $motifMatrix = shift;
    my $File        = shift;
	my $OUT         = $File->Write;

    for( my $i = 0; $i < scalar @$motifMatrix; $i++ ){
        my $frequencies = $motifMatrix->[$i];
        print $OUT join( "\t", @$frequencies ), "\n";
	}

    $File->Close;

    return 1;
}

sub _process_matrix_file
{
    my $self   = shift;
	my $format = _check_transfac_format( $self->get_file );

	if( $format =~ /^Pos/ ){
		_transfac_to_jaspar( $self );
	}
	my $matrix = _process_jaspar_format( $self );

	die "ERROR: Failed processing matrix file $self->get_file\n" 
		if !$matrix;

	$self->{'motifMatrix'} = $matrix;
	$self->{'motif_length'} = scalar @{$matrix->[0]};

	return 1;
}

sub print_matrix
{
	my $self      = shift;
    my $matrix    = $self->{'motifMatrix'};
    my $alphabet  = $self->{'alphabet'};
    my $file_base = $self->get_base;

	print "MATRIX for $file_base\n";

    for( my $i = 0; $i < scalar @$alphabet; $i++ ){
        my $frequencies = $matrix->[$i];
        my $base        = $alphabet->[$i];

        print "$base: ", join( ' ', @$frequencies ), "\n";
    }

    return 1;
}

sub _process_jaspar_format
{
	my $self         = shift;
	my $alphabet     = $self->{'alphabet'};
	my @dummy_column = ( 0.23, 0.27, 0.24, 0.26 );

	my $IN = $self->Open;
    my %tmp_matrix;

    while( my $line = <$IN> ){
		chomp $line;
        my( $base, @frequencies ) = split( /\s+|\t+/, $line );

		# Remove anything but the 4 letters ACGT
        $base =~ s/[^ACGT]//g;

		my $matrix_length  = scalar @frequencies;

		if( $matrix_length < 7 ){
			my $number_add = 7 - $matrix_length;
			my $dummy_freq = shift @dummy_column;

			for( my $i = 0; $i < $number_add; $i++ ){
				push( @frequencies, $dummy_freq );
			}

			$tmp_matrix{$base} = \@frequencies;
		}
		else{
			$tmp_matrix{$base} = \@frequencies;
		}
    }

	$self->Close;

    my @motifMatrix;

    foreach my $base ( @$alphabet ){
        my $frequencies = $tmp_matrix{$base};
        push( @motifMatrix, $frequencies );
    }

    return \@motifMatrix;
}

sub _check_transfac_format
{
	my $file   = shift;
	my $header = `grep -P \"^Pos\t[ACGT]\" "$file"`;
	chomp $header;

	return $header;
}

sub _transfac_to_jaspar
{
    my $self     = shift;
	my $file     = $self->get_file;
    my @alphabet = ( 'A', 'C', 'G', 'T' );

    my %transfac;

    open( IN, $file ) or die "ERROR: Could not open file $file\n";
    my @data   = <IN>;
    close IN;

	my $header = shift @data;
	chomp $header;
    my @fields = split( /\s+|\t+/, $header );

    for( my $i = 0; $i < scalar @data; $i++ ){
        my $line  = $data[$i];
        chomp $line;

        my @split = split( /\s+|\t+/, $line );

        for( my $f = 0; $f < scalar @split; $f++ ){
			my $field = $fields[$f];
			my $value = $split[$f];
			$value    = sprintf( "%.3f", $value );
            push( @{$transfac{$field}}, $value );
        }
    }

    # Convert to JASPAR format
    my @jaspar;

    foreach my $base ( @alphabet ){
        if( $transfac{$base} ){
            my $line = "$base: " . join( ' ', @{$transfac{$base}} );
            push( @jaspar, $line );
        }
    }

	my $outDir = $self->get_outDir;
	my $base   = $self->get_base;
	my $jaspar = "$outDir/$base.mat";
	open( OUT, ">$jaspar" ) or
		die "ERROR: Could not create motif file $jaspar\n";
    print OUT join( "\n", @jaspar ), "\n";
	close OUT;
	$self->set_file( $jaspar );

    return 1;
}

sub _normalize
{
	my $self        = shift;
	my $motifMatrix = $self->{'motifMatrix'};

	# Get column sums
	my @col_sums;

	for my $frequencies ( @$motifMatrix ){
		for( my $i = 0; $i < scalar @$frequencies; $i++ ){
			my $freq       = $frequencies->[$i];
			$col_sums[$i] += $freq;
		}
	}

	# Normalize frequencies
	for my $frequencies ( @$motifMatrix ){
		for( my $i = 0; $i < scalar @$frequencies; $i++ ){
			$frequencies->[$i] /= $col_sums[$i];
			$frequencies->[$i]  = sprintf( "%.4f", $frequencies->[$i] );
		}
	}

	return 1;
}

1;

#-------------------------------------------------------------------------------
package POSTPROCESSING;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $file      = $arguments{'file'}       or
		die "ERROR: Please provide an argument for 'file'\n";
    my $outDir    = $arguments{'outDir'}     or
		die "ERROR: Please provide an argument for 'outDir'\n";
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";
	my $hitFile   = $file;
	$hitFile      =~ s/\.adb$/.hit/;

	# Constructor
	my $self = SUPER::new $class(
	 	file   => $file,
		outDir => $outDir,
	);
	$self->{'config'} = $Config;
	$self->{'hitFile'}    = $hitFile;
	bless( $self, $class );

	return $self;
}

sub get_hitFile
{
	my $self = shift;
	return $self->{'hitFile'};
}

sub merge_positions
{
	my $self  = shift;
	my $files = shift;

	# Merge ADB data
	my $iFile = shift @$files;
	open( ADB1, $iFile ) or
		die "ERROR: Could not open file $iFile\n";

	print STDOUT "  Merging positions ...\n";
	my $time0 = time;

	# Remove header
	my $header1 = <ADB1>;
	chomp $header1;
	my @data1   = <ADB1>;
	chomp @data1;
	close ADB1;

	for my $iFile ( @$files ){
		open( ADB2, $iFile ) or
			die "ERROR: Could not open file $iFile\n";
		# Remove header
		my $header2 = <ADB2>;
		my @data2   = <ADB2>;
		chomp @data2;
		close ADB2;
		@data1      = _merge( \@data1, \@data2 );
	}

	# Write merged data to file
	my $OUT = $self->Write;
	print $OUT "$header1\n";

	for my $line ( @data1 ){
		print $OUT "$line\n";
	}
	$self->Close;

	# Sort positions
	my $mFile = $self->get_file;
	`sort -Vk1,1 -k2,2n $mFile > $mFile.tmp && mv -f $mFile.tmp $mFile`;

	my $num = scalar @data1;

	if( $num > 1 ){
		print STDOUT "    Total number of ADB positions = $num\n";
	}
	else{
		print STDOUT "    Failed to merge ADB positions!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _merge
{
	my $data1 = shift;
	my $data2 = shift;
	my %exist;

	for my $line1 ( @$data1 ){
		my @split = split( "\t", $line1 );
		my $chr   = $split[0];
		my $start = $split[1];

		$exist{"$chr-$start"} = $line1;
	}

	# Find overlap with data2
	my @data;

	for my $line2 ( @$data2 ){
		my @split2 = split( "\t", $line2 );
		my $chr    = $split2[0];
		my $start  = $split2[1];
		my $end    = $split2[2];

		if( $exist{"$chr-$start"} ){
			my $line1  = $exist{"$chr-$start"};
			my @split1 = split( "\t", $line1 );

			my @array  = (
				$chr,                      # CHR
				$start,                    # START
				$end,                      # END
				"$split1[3],$split2[3]",   # S_BASE
				"$split1[4],$split2[4]",   # W_BASE
				"$split1[5],$split2[5]",   # S_READS
				"$split1[6],$split2[6]",   # W_READS
				"$split1[7],$split2[7]",   # WS_RATIO
				$split1[8],                # SNP_STATUS (same position always has same genotyping status)
			);
			my $line = join( "\t", @array );
			push( @data, $line );
			delete $exist{"$chr-$start"};
		}
		else{
			push( @data, $line2 );
		}
	}

	# Get remaining lines from data1
	while( my( $key, $line1 ) = each %exist ){
		push( @data, $line1 );
	}

	return @data;
}

sub add_statistics
{
	my $self      = shift;
	my $procFile  = $self->get_file;
	my $outDir    = $self->get_outDir;
	my $Config    = $self->{'config'};
	my $statsFile = "$procFile.stats";

	print STDOUT "  Adding statistics ...\n";
	my $time0  = time;

	# Print header
	my $PROC   = $self->Open;
	open( OUT, ">$statsFile" );
	my $header = <$PROC>;
	chomp $header;
	my @header = split( "\t", $header );
	my @hStats = (
		'S_READS_AVG',
		'W_READS_AVG',
		'WS_RATIO_AVG',
	);
	my @hOut   = ( @header, @hStats );
	print OUT join( "\t", @hOut ), "\n";
	my $num;

	while( my $line = <$PROC> ){
		chomp $line;
		my @split = split( "\t", $line );
		my @stats;

		for my $field ( @split ){

			if( $field =~ /\d,\d/ ){
				my @data = split( ',', $field );
				my $Stat = new STATISTICS(
					data => \@data,
				);
				push( @stats, $Stat->arithmetic_mean );
			}
		}

		if( @stats ){
			my @proc = ( @split, @stats );
			print OUT join( "\t", @proc ), "\n";
		}
		else{
			my @proc = ( @split, $split[5], $split[6], $split[7] );
			print OUT join( "\t", @proc ), "\n";
		}
		$num++;
	}
	$self->Close;
	close OUT;

	if( $num > 1 && -s $statsFile ){
		print STDOUT "    Number of processed lines = $num\n";
		`mv $statsFile $procFile`;
	}
	else{
		print STDOUT "    Failed to calculate statistics!\n";
		`rm -f $statsFile`;
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub add_ars
{
	my $self     = shift;
	my $ArScores = shift;
	my $procFile = $self->get_file;
	my $Config   = $self->{'config'};
	my $procTmp  = "$procFile.tmp";

	print STDOUT "  Adding ARS scores ...\n";
	my $time0    = time;

	# Print header
	my $PROC   = $self->Open;
	open( OUT, ">$procTmp" );
	my $header = <$PROC>;
	chomp $header;
	my @header = split( "\t", $header );
	my @add    = ( 'ARS_GROUP', 'ARS_GLOBAL' );
	@header    = ( @header, @add );
	print OUT join( "\t", @header ), "\n";
	my $num;

	while( my $line = <$PROC> ){
		# chrX	132450499	132450500	A	N	11	0	0	g
		chomp $line;
		my @split     = split( "\t", $line );
		$num++;

		# Find out if the SNP has concordant s_bases
		my @bases    = split( ',', $split[3] );
		my @sReads   = split( ',', $split[5] );
		my @wReads   = split( ',', $split[6] );
		my @wsRatios = split( ',', $split[7] );
		my %sSame;
		my %sReads;
		my %wReads;
		my %wsRatios;

		for( my $i = 0; $i < scalar @bases; $i++ ){
			my $base   = $bases[$i];
			my $sReads = $sReads[$i];
			my $wReads = $wReads[$i];
			my $ratio  = $wsRatios[$i];

			$sSame{$base}++;
			push( @{$sReads{$base}},   $sReads );
			push( @{$wReads{$base}},   $wReads );
			push( @{$wsRatios{$base}}, $ratio );
		}

		# Go through each group found
		my @arsGroup;
		my $arsHigh = 1; # >= 0.5
		my $arsLow  = 1; # <  0.5
		my %arsVote;

		for my $base ( keys %sSame ){
			my $numExp   = $sSame{$base};
			my $readsAvg = 0;
			my $ratioAvg = 0;
			my $maxSum   = 0;

			# Calculate average reads and ratio within each group
			for( my $i = 0; $i < scalar @{$sReads{$base}}; $i++ ){
				my $sum    = $sReads{$base}[$i] + $wReads{$base}[$i];
				$maxSum    = $sum if $sum > $maxSum;

				$readsAvg += $sReads{$base}[$i];
				$ratioAvg += $wsRatios{$base}[$i];
			}
			$readsAvg /= $numExp;
			$ratioAvg /= $numExp;

			my $num  = $numExp;
			$num     = 3 if $num > 3;
			my $ars  = $ArScores->get_ars_score(
				$num,
				$ratioAvg,
				$readsAvg,
			);
			push( @arsGroup, "$numExp$base\_$ars" );

			if( $ars >= 0.5 ){
				$arsHigh++;
			}
			else{
				$arsLow++;
			}
			$arsVote{"$numExp$base"} = [$numExp, $maxSum, $ars];
		}

		# Get best ars score and filter out if maxSum doesn't cut it
		my @sorted  = sort{ $arsVote{$b}[0] <=> $arsVote{$a}[0] } keys %arsVote;
		my $key1    = shift @sorted;
		my $numExp1 = $arsVote{$key1}[0];
		my $numExp2 = 0;
		my $numExps = keys %arsVote;

		for my $key ( @sorted ){
			$numExp2 += $arsVote{$key}[0];
		}

		# Report ARS score if cadidate meets criteria or report -1
		my $maxNum  = $arsVote{$key1}[1];
		my $arsGlob = -1;

		if( $numExp1 > $numExp2 ){
			$arsGlob = $arsVote{$key1}[2];
		}
		elsif( $arsHigh/$arsLow <= 0.4 ){
			# Less than 30% of the groups have a high ARS value
			$arsGlob = $arsVote{$key1}[2];
		}

		my $arsGroup  = join( ',', @arsGroup );
		my @addScores = ( $arsGroup, $arsGlob );

		@split = ( @split, $arsGroup, $arsGlob );
		print OUT join( "\t", @split ), "\n";
	}
	$self->Close;
	close OUT;

	if( $num > 1 && -s $procTmp ){
		print STDOUT "    Number of processed lines = $num\n";
		`mv $procTmp $procFile`;
	}
	else{
		print STDOUT "    Failed to add AR scores!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub	add_reference_bases
{
	my $self     = shift;
	my $procFile = $self->get_file;
	my $outDir   = $self->get_outDir;
	my $Config   = $self->{'config'};
	my $genome   = $Config->get_value( 'REFGEN_FILE' );
	my $bedtools = $Config->get_value( 'BEDTOOLS' );
	my $refFile  = "$procFile.ref";

	print STDOUT "  Annotating reference allele ... \n";
	my $time0    = time;

	# Generate BED file with base coordinates
	my $bedFile  = "$outDir/reference.bed";
	`tail -n +2 $procFile | awk '{print \$1,\$2-1,\$2}' OFS='\\t' > $bedFile`;

	# Get genomic bases
	my @refBases = `$bedtools getfasta -fi $genome -bed $bedFile -tab -fo /dev/stdout | cut -f2 | tr "[:lower:]" "[:upper:]"`;
	chomp @refBases;

	#  Write header
	my $PROC   = $self->Open;
	open( OUT, ">$refFile" ) or
		die "ERROR: Could not open file $refFile!\n";
	my $header = <$PROC>;
	chomp $header;
	my @header = split( "\t", $header );
	splice( @header, 3, 0, 'REF_BASE' );
	print OUT join( "\t", @header ), "\n";

	my $num = 0;

	while( my $line = <$PROC> ){
		chomp $line;
		my @split   = split( "\t", $line );
		my $refBase = $refBases[$num];
		splice( @split, 3, 0, $refBase );

		print OUT join( "\t", @split ), "\n";
		$num++;
	}
	$self->Close;
	close OUT;

	if( $num > 0 && -s $refFile ){
		print STDOUT "    Number of processed lines = $num\n";
		`head -n1 $refFile > $procFile`;
		`tail -n +2 $refFile | sort -Vk1,1 -k2,2n >> $procFile`;
		`rm -f $refFile $bedFile`;
	}
	else{
		print STDOUT "    Failed to add reference bases!\n";
		`rm -f $refFile`;
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1,
}

sub find_motif_matches
{
	my $self     = shift;
	my $mFiles   = shift;
	my $procFile = $self->get_file;
	my $outDir   = $self->{'outDir'};
	my $Config   = $self->{'config'};

	print STDOUT "  Finding motif matches ...\n";
	my $time0        = time;

	# Load MOTIFS
	my $motifs  = $self->_load_motifs( $mFiles );
	if( !$motifs ){
		print STDOUT "    Failed loading motifs!\n";
		return 0;
	}

	# Extract genomic sequences
	print STDOUT "    Extracting REF sequences\n";
	my $ref_seqs = $self->_extract_ref_sequences;
	if( !$ref_seqs ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	# Print allele sequences to a temporary FASTA file
	print STDOUT "    Building allele sequences\n";
	my $allele_seqs = $self->_build_allele_sequences( $ref_seqs );
	if( !$allele_seqs ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	# Find MOTIF matches
	print STDOUT "    Finding matches\n";
	my $matches = $self->_find_matches( $allele_seqs, $motifs );
	if( !$matches ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	# print_results
	print STDOUT "    Writing results\n";
	my $status  = $self->_write_match_results( $matches );
	if( !$status ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _load_motifs
{
	my $self   = shift;
	my $mFiles = shift;
	my $outDir = $self->{'outDir'};
	my $Config = $self->{'config'};
	my @motifs;

	if( -s $mFiles ){
		open( MAT, $mFiles ) or (
			print STDOUT "    Could not open file: $mFiles at '_load_motifs'\n" and
			return 0
		);

		while( my $m_file = <MAT> ){
			chomp $m_file;

			if( -s $m_file ){
				my $Motif = new MOTIF(
					file       => $m_file,
					outDir    => $outDir,
					config => $Config,
				);
				push( @motifs, $Motif );
			}
		}
		return \@motifs if @motifs;
	}
	return 0;
}

sub _extract_ref_sequences
{
	my $self     = shift;
	my $procFile = $self->get_file;
	my $outDir   = $self->{'outDir'};
	my $Config   = $self->{'config'};
	my $padding  = $Config->get_value('SNP_PADD');
	my $genome   = $Config->get_value('REFGEN_FILE');
	my $bedtools = $Config->get_value('BEDTOOLS');

	# Generate BED file using padded regions around each SNP
	my $bedFile = "$outDir/ref_seqs.bed";
	`tail -n +2 $procFile | awk '{print \$1,\$2-$padding,\$2+$padding-1}' OFS='\\t' > $bedFile`;

	my $ref_seqs = "$outDir/ref_seqs.txt";
	`$bedtools getfasta -fi $genome -bed $bedFile -tab -fo /dev/stdout | cut -f2 > $ref_seqs`;

	return $ref_seqs if -s $ref_seqs;
	return 0;
}

sub _build_allele_sequences
{
	my $self     = shift;
	my $refFile  = shift;
	my $procFile = $self->get_file;
	my $outDir   = $self->{'outDir'};
	my $Config   = $self->{'config'};
	my $padding  = $Config->get_value( 'SNP_PADD' );
	my $seqFile  = "$outDir/seqs.fasta";

	my $IN     = $self->Open;
	my $header = <$IN>;
	open( SEQ, $refFile ) or
		die "ERROR: Could not open file: $refFile at '_build_allele_sequences'\n";
	open( OUT, ">$seqFile" ) or
		die "ERROR: Could not create file: $seqFile at '_build_allele_sequences'\n";

	# Print header
	print OUT ">allele-sequences\n";

=pod
0 CHR
1 START
2 END
3 REF_BASE
4 S_BASE
5 W_BASE
6 S_READS
7 W_READS
=cut
	while( my $line = <$IN> ){
		chomp $line;
		my @split   = split( "\t", $line );
		my $r_base  = $split[2];
		my @s_bases = split( ',', $split[3] );
		my @w_bases = split( ',', $split[4] );
		my $ref_seq = uc <SEQ>;
		chomp $ref_seq;

		# Get most abundant s_base
		my %bases;

		for my $base ( @s_bases ){
			$bases{$base}++;
		}
		my @sorted = sort{ $bases{$b} <=> $bases{$a} } keys %bases;
		my $s_base = $sorted[0];

		# Get most abundant w_base
		my $w_base;

		for my $base ( @w_bases ){
			$bases{$base}++;
		}
		@sorted = sort{ $bases{$b} <=> $bases{$a} } keys %bases;

		for my $base ( @sorted ){
			next if $base eq 'N';
			$w_base = $base;
		}
		$w_base = 'N' if !$w_base;

		# Print sequences for both alleles
		my $s_seq = $ref_seq;
		my $w_seq = $ref_seq;

		if( $s_base eq $r_base ){
			substr( $s_seq, $padding, 1, $s_base );
			substr( $w_seq, $padding, 1, $w_base );
			print OUT "$s_seq$w_seq";
		}
		else{
			substr( $s_seq, $padding, 1, $w_base );
			substr( $w_seq, $padding, 1, $s_base );
			print OUT "$s_seq$w_seq";
		}
	}
	print OUT "\n";

	$self->Close;
	close SEQ;
	close OUT;

	return $seqFile if -s $seqFile;
	return 0;
}

sub _find_matches
{
	my $self     = shift;
	my $seqFile  = shift;
	my $motifs   = shift;
	my $procFile = $self->get_file;
	my $outDir   = $self->{'outDir'};
	my $Config   = $self->{'config'};
	my $padding  = $Config->get_value('SNP_PADD');
	my $moods    = $Config->get_value('MOODS');
	my $pval_cf  = $Config->get_value('MOODS_PVAL');

	# Generate temporary motif files
	my @fw_motif_files;
	my @rc_motif_files;

	for my $Motif ( @$motifs ){
		my $m_file  = $Motif->get_file;
		my $m_base  = $Motif->get_base;
		my $fw_file = $Motif->get_forward_file;
		my $rc_file = $Motif->get_reverse_file;
		push( @fw_motif_files, $fw_file );
		push( @rc_motif_files, $rc_file );
	}
	my $fw_motif_list = join( ' ', @fw_motif_files );
	my $rc_motif_list = join( ' ', @rc_motif_files );

	# Run MOODS
	# MOODS produces zero-based positions in its output
	my @fw_out = `$moods -f $pval_cf $seqFile $fw_motif_list 2>&1 | grep -vP "^(cal|loa|Mat|Hit|Tot|\\n+)" | awk 'NF'`;
	my @rc_out = `$moods -f $pval_cf $seqFile $rc_motif_list 2>&1 | grep -vP "^(cal|loa|Mat|Hit|Tot|\\n+)" | awk 'NF'`;

	# Process MOODS output
	my $fw_moods_out  = _read_moods_output( \@fw_out );
	my $rc_moods_out  = _read_moods_output( \@rc_out );

	# Deconvolute MOODS output
	my $fw_matches    = _deconvolute_moods_hits( $fw_moods_out, $motifs, $padding );
	my $rc_matches    = _deconvolute_moods_hits( $rc_moods_out, $motifs, $padding );
	my @matches       = ( $fw_matches, $rc_matches );

	return \@matches;
}

sub _read_moods_output
{
	my $output = shift;
	my %moods_out;
	my $m_base;
	my @scores;

	while( my $line = shift @$output ){
		chomp $line;

		if( $line =~ /^\d/ ){
			push( @scores, $line );
		}
		else{
			if( @scores ){
				my @cp_scores = @scores;
				$moods_out{$m_base} = \@cp_scores;
				undef @scores;
			}

			$m_base = $line;
			$m_base =~ s/^.*\///;
			$m_base =~ s/_(fw|rc)\.mat$//;
		}
	}
	$moods_out{$m_base} = \@scores;

	return \%moods_out;
}

sub _deconvolute_moods_hits
{
	my $moods_out = shift;
	my $motifs    = shift;
	my $padding   = shift;
	my %matches;

	for my $Motif ( @$motifs ){
		my $m_base  = $Motif->get_base;
		my $m_len   = $Motif->get_motif_length;
		my $c_score = $Motif->get_canonical_score;
		my $hits    = $moods_out->{$m_base} or next;

		my $hit     = shift @$hits;
		my $i       = 0;
		my $snp_pos = ( 2 * $i + 1 ) * $padding;
		# MOODS produces zero-based positions in its output
		my(
			$h_start,
			$score,
		) = split( "\t", $hit );
		my $h_end   = $h_start + $m_len - 1;
		
		do{
			my $aa = sprintf( "%.3f",$score/$c_score );
			if( $h_start > $snp_pos + $padding - 1 ){
				$i++;
				$snp_pos = ( 2 * $i + 1 ) * $padding;
			}
			elsif( $h_start <= $snp_pos and $snp_pos <= $h_end ){
				# Correct h_start and h_end
				my $rel_start = $h_start - $i * 2 * $padding;
				my $rel_end   = $rel_start + $m_len - 1;

				push( @{$matches{$i}{"$m_base:$rel_start:$rel_end"}}, ($score, $score/$c_score) );

				$hit   = shift @$hits;
				(
					$h_start,
					$score,
				) = split( "\t", $hit );
				$h_end = $h_start + $m_len - 1;
			}
			else{
				$hit   = shift @$hits;
				(
					$h_start,
					$score,
				) = split( "\t", $hit );
				$h_end = $h_start + $m_len - 1;
			}
		} until( scalar @$hits == 0 );
	}

	return \%matches;
}

sub _write_match_results
{
	my $self     = shift;
	my $matches  = shift;
	my $procFile = $self->get_file;
	my $hitFile  = $self->get_hitFile;
	my $Config   = $self->{'config'};
	my $score_cf = $Config->get_value( 'MIN_SCORE' );
	my $padding  = $Config->get_value( 'SNP_PADD' );
	my $tmpFile  = "$hitFile.tmp";

	if( scalar @$matches == 0 ){
		print STDOUT "    No motif matches found\n";
		return 0;
	}

	open( OUT, ">$tmpFile" ) or
		die "    Failed to create file: $tmpFile!\n";

	my $PROC       = $self->Open;
	my $header     = <$PROC>;
	chomp $header;
	my @header     = split( "\t", $header );

	my @hit_header = (
	 	'MOTIF_NAME',
		'TF_NAME',
		'HIT_START',
		'HIT_END',
		'HIT_LENGTH',
		'HIT_STRAND',
		'HIT_SCORE_1',
		'HIT_SCORE_2',
		'HIT_NORM_SCORE_1',
		'HIT_NORM_SCORE_2',
	);
	my $insert = 14;
	splice( @header, $insert, 0, @hit_header );
	print OUT join( "\t", @header ), "\n";

	my $i = 0;

	while( my $line = <$PROC> ){
		chomp $line;
		my @split = split( "\t", $line );
		my $start = $split[1];
		my $sign  = '+';

		# Go through each match type (fw and rc)
		for my $match ( @$matches ){
			# Hits on allele 1
			if( $match->{$i} ){
				# {$i} = [{$m_base:$rel_start:$rel_end} = [$score, $score/$c_score]]
				for my $h_coor ( keys %{$match->{$i}} ){
					my(
					 	$m_base,
						$h_start,
						$h_end,
					) = split( ':', $h_coor );
					# Get motif length
					my $m_len = $h_end - $h_start + 1;
					# Correct h_start and h_end relative to SNP position
					$h_start = $h_start - $padding;
					$h_end   = $h_end   - $padding;

					my(
					 	$m_code,
						$m_version,
						$tf_name,
					) = split( '_', $m_base );
					my $m_name = "$m_code\_$m_version";

					my(
						$score1,
						$n_score1,
					) = @{$match->{$i}{$h_coor}};
					next if $n_score1 < $score_cf;

					# Hits on allele 2
					if( $match->{$i+1}{$h_coor} ){
						# {$i} = [{$m_base:$rel_start:$rel_end} = [$score, $score/$c_score]]
						my(
							$score2,
							$n_score2,
						) = @{$match->{$i+1}{$h_coor}};

						if( $n_score1 > $n_score2 ){
							my @hit = (
								$m_name,
								$tf_name,
								$h_start,
								$h_end,
								$m_len,
								$sign,
								sprintf( "%.3f", $score1 ),
								sprintf( "%.3f", $score2 ),
								sprintf( "%.3f", $n_score1 ),
								sprintf( "%.3f", $n_score2 ),
							);
							splice( @split, $insert, 0, @hit );
							print OUT join( "\t", @split ), "\n";
						}
					}
					else{
						my @hit = (
							$m_name,
							$tf_name,
							$h_start,
							$h_end,
							$m_len,
							$sign,
							sprintf( "%.3f", $score1 ),
							'0.000',
							sprintf( "%.3f", $n_score1 ),
							'0.000',
						);
						splice( @split, $insert, 0, @hit );
						print OUT join( "\t", @split ), "\n";
					}
				}
			}
			$sign = '-';
		}
		$i += 2;
	}
	$self->Close;
	close OUT;

	`head -n1 $tmpFile > $hitFile`;
	`tail -n +2 $tmpFile | sort -Vk1,1 -k2,2n >> $hitFile`;
	`rm -f $tmpFile`;

	return 1;
}

sub annotate
{
	my $self     = shift;
	my $value    = shift;
	my $adFields = shift;
	my $datBed   = $self->get_file;
	my $hitBed   = $self->get_hitFile;
	my $outDir   = $self->get_outDir;
	my $fields   = 15; # Number of fields in ADB file without annotation
	my $time0    = time;

	if( $value !~ /^(DISEASE|GENE)$/ ){
		print STDOUT "    Could not understand value: $value!\n";
		return 0;
	}
	print STDOUT "  Annotating positions with closest $value ... \n";

	if( -s $datBed ){
		print STDOUT "    Annotating DAT file\n";

		if( $value eq 'DISEASE' ){
			$self->_annotate_disease( $datBed, $fields );
		}
		elsif( $value eq 'GENE' ){
			$self->_annotate_genes( $datBed, $fields + $adFields );
		}
	}
	elsif( -s $hitBed ){
		print STDOUT "    Annotating HIT file\n";
		# Add 10 fields from the hit annotation
		$fields += 10;

		if( $value eq 'DISEASE' ){
			$self->_annotate_disease( $hitBed, $fields );
		}
		elsif( $value eq 'GENE' ){
			$self->_annotate_genes( $hitBed, $fields + $adFields );
		}
	}
	else{
		print STDOUT "    No files to annotate found!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _annotate_disease
{
	my $self     = shift;
	my $aBed     = shift;
	my $fields   = shift;
	my $Config   = $self->{'config'};
	my $bBed     = $Config->get_value( 'DISANNO_FILE' );
	my $bedtools = $Config->get_value('BEDTOOLS');
	my $chroms   = $Config->get_value('CHROMOSOMES');
	my $annoFile = $aBed . '.anno';

	# Find closest disease SNP on each chromosome
	# annoLine:
	# rs61766198;Inflammatory_bowel_disease-EU;1;0	127
	my @annoLines;

	for my $chrom ( @$chroms ){
		my $acBed = "$aBed.$chrom";
		my $bcBed = "$bBed.$chrom";
		`grep -P "^$chrom\t" $aBed > $acBed`;
		`grep -P "^$chrom\t" $bBed > $bcBed`;
		next if !-s $acBed;

		my @lines;
		if( -s $bcBed ){
			@lines = `$bedtools closest -D "a" -a $acBed -b $bcBed 2> /dev/null`;
		}
		else{
			my $dummy = "na;na;na;na\tna";
			my $num   = `cat $acBed | wc -l`;

			for( my $i = 0; $i < $num ; $i++ ){
				push( @lines, $dummy );
			}
		}
		push( @annoLines, @lines );
	}
	chomp @annoLines;
	# Remove chromosome files
	`rm -f $aBed.chr* $bBed.chr*`;

	# Attach annotation to aBed lines
	open( OUT, ">$annoFile" ) or
		die "ERROR: Could not create file $annoFile\n";

	my $header = `head -n1 $aBed`; chomp $header;
	my @hSplit = split( "\t", $header );
	my @header = splice( @hSplit, 0, $fields );
	my @hAnno  = (
		'DISEASE',
		'AUTOIMMUNE',
		'AUTOINFLAMMATORY',
		'DIS_SNP_ID',
		'DIS_SNP_DIST',
		'DIS_SNP_ABS_DIST',
	);
	my @hOut = ( @header, @hAnno );
	print OUT join( "\t", @hOut ), "\n";

	for my $line ( @annoLines ){
		chomp $line;
		my @split   = split( "\t", $line );
		my @aFields = splice( @split, 0, $fields );
		my( $anno, $snpDist ) = splice( @split, -2 );
		my(
			$snpId,
			$disease,
			$autoimmune,
			$autoinflam,
		) = split( /[;\t]/, $anno );
		my $absSnpDist = 'na';
		$absSnpDist    = abs $snpDist if $snpDist ne 'na';
		push( @aFields, $disease );
		push( @aFields, $autoimmune );
		push( @aFields, $autoinflam );
		push( @aFields, $snpId );
		push( @aFields, $snpDist );
		push( @aFields, $absSnpDist );

		print OUT join( "\t", @aFields ), "\n";
	}
	close OUT;

	if( -s $annoFile ){
	 	print STDOUT "    Diseases annotated succesfully\n";
		# Rename annotated file
		`mv -f $annoFile $aBed`;
	}
	else{
	 	print STDOUT "    Failed!\n";
		`rm -f $annoFile`;
		return 0;
	}

	return 1;
}

sub _annotate_genes
{
	my $self     = shift;
	my $aBed     = shift;
	my $fields   = shift;
	my $Config   = $self->{'config'};
	my $bBed     = $Config->get_value( 'GENANNO_FILE' );
	my $bedtools = $Config->get_value('BEDTOOLS');
	my $chroms   = $Config->get_value('CHROMOSOMES');
	# Set max number of columns that will be kept and appended with the annotation
	my $annoFile = $aBed . '.anno';

	# Remove header
	`tail -n +2 $aBed > $aBed.tmp`;
	# Find closest disease SNP
	# annoLine:
	# DDX11L1	+	E1	54
	my @annoLines;

	for my $chrom ( @$chroms ){
		my $acBed = "$aBed.$chrom";
		my $bcBed = "$bBed.$chrom";
		`grep -P "^$chrom\t" $aBed > $acBed`;
		`grep -P "^$chrom\t" $bBed > $bcBed`;
		next if !-s $acBed;

		my @lines;
		if( -s $bcBed ){
			@lines = `$bedtools closest -D "a" -a $acBed -b $bcBed 2> /dev/null`;
		}
		else{
			my $dummy = "na\tna\tna\tna";
			my $num   = `cat $acBed | wc -l`;

			for( my $i = 0; $i < $num ; $i++ ){
				push( @lines, $dummy );
			}
		}
		push( @annoLines, @lines );
	}
	chomp @annoLines;
	# Remove chromosome files
	`rm -f $aBed.chr* $bBed.chr*`;

	# Attach annotation to aBed lines
	open( OUT, ">$annoFile" ) or
		die "ERROR: Could not create file $annoFile\n";

	my $header = `head -n1 $aBed`; chomp $header;
	my @hSplit = split( "\t", $header );
	my @header = splice( @hSplit, 0, $fields );
	my @hAnno  = (
	 	'GENE',
	 	'DESCRIPTION',
		'STRAND',
		'GEN_DIST',
		'GEN_ABS_DIST',
	);
	my @hOut = ( @header, @hAnno );
	print OUT join( "\t", @hOut ), "\n";

	for my $line ( @annoLines ){
		chomp $line;
		my @split   = split( "\t", $line );
		my @aFields = splice( @split, 0, $fields );
		my(
			$geneId,
			$strand,
			$feature,
			$geneDist,
		) = splice( @split, -4 );
		my $absGeneDist = 'na';
		$absGeneDist    = abs $geneDist if $geneDist ne 'na';
		push( @aFields, $geneId );
		push( @aFields, $strand );
		push( @aFields, $feature );
		push( @aFields, $geneDist );
		push( @aFields, $absGeneDist );

		print OUT join( "\t", @aFields ), "\n";
	}
	close OUT;

	if( -s $annoFile ){
	 	print STDOUT "    Genes annotated succesfully\n";
		# Rename annotated file
		`mv -f $annoFile $aBed`;
	}
	else{
	 	print STDOUT "    Failed!\n";
		`rm -f $annoFile`;
		return 0;
	}

	return 1;
}

1;
