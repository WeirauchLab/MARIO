#!/usr/bin/perl -w
use strict;
use Cwd;
use Getopt::Std;
use Parallel::ForkManager;
use Data::Dumper;

my $progName = $0;
my $version  = '3.9.0';
my $created  = '011017';
my $modified = '092418';

my %options;
# EHKLNPQRSTUVWYZ
# abcdfhnmopqrstxyz
# available: egklnvw
getopts('I:F:A:D:M:B:C:X:O:G:p:abcdfhimoqrstuxyz', \%options);

# Display help
if( ! %options ){
	MESSAGES::die_with_usage( $progName, $version, $created, $modified );
}
if( $options{'h'} or ! %options ){
	MESSAGES::print_usage( $progName, $version, $created, $modified );
	exit;
}

if( $options{'x'} or $options{'y'} or $options{'z'} ){
	# Print pipeline scheme
	MESSAGES::print_scheme( $progName, $version ) if $options{'x'};
	# Print example config file
	MESSAGES::print_configuration_file( $version ) if $options{'y'};
	# Print ARS config' file
	MESSAGES::print_ars_file() if $options{'z'};
	exit;
}
# Create output directory (if specified)
my $outDir = $options{'O'} || '.';
`mkdir -p $outDir/tmp`
	if $outDir;

# Set TMPDIR environment variable to $outDir/tmp
$ENV{TMPDIR} = "$outDir/tmp";

# Add version to options
$options{'VERSION'} = $version;

# Configure the program
my $Config = new CONFIGURATION(
 	options => \%options,
	outDir  => $outDir,
);

#-------------------------------------------------------------------------------
# MAIN
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

print STDOUT "-------------------------------------------------------------------------------\n";
my $time0 = time;

# Processing input files
#-------------------------------------------------------------------------------
# Inputs:
# I SRA_ID
# S SRA
# F FASTQ_read1:2 FASTQ_read2
# A BAM
# D DAT

# Get input type together with correct files
#-------------------------------------------------------------------------------
my $iType  = $Config->get_value('iType');
my @inputs = split( ',', $Config->get_value($iType) );
my $iNum   = scalar @inputs;

if( $options{'i'} ){
	my $outDir  = $Config->get_value('O');
	print STDOUT "Concatenation of input files requested\n";

	# Download multiple SRA files and converte them to FASTQ
	if( $Config->get_value('I') ){
		my @fastqFiles;

		for( my $i = 0; $i < $iNum; $i++ ){
			my $input = $inputs[$i];
			print STDOUT "  > Downloading $input\n";

			$input = process_sra( $input, $Config );
			push( @fastqFiles, $input );
		}
		@inputs = @fastqFiles;
		$iNum   = scalar @inputs;
		$Config->set_value( 'F', \@inputs );

		print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
	}

	# Merged/Concatenate multiple FASTQ files into one
	if( $Config->get_value('F') ){
		print STDOUT "  > Concatenating FASTQ files\n";
		my $outBase      = $outDir;
		$outBase         =~ s/^.*\///;
		$outBase         =~ s/\/+$//;
		my $mergedFastq1 = "$outDir/$outBase\_1.fastq.gz";
		my $mergedFastq2 = "$outDir/$outBase\_2.fastq.gz";

		for( my $i = 0; $i < $iNum; $i++ ){
			print STDOUT "  > $inputs[$i]\n";
			my( $input1, $input2 ) = split( ':', $inputs[$i] );
			die "ERROR: File $input1 does not exist or it's empty\n"
				unless -s $input1;

			`zcat $input1 | gzip >> $mergedFastq1` if $input1 =~ /gz$/;
			`cat $input1  | gzip >> $mergedFastq1` if $input1 !~ /gz$/;

			if( $input2 ){
				die "ERROR: File $input2 does not exist or it's empty\n"
					unless -s $input2;
				`zcat $input2 | gzip >> $mergedFastq2` if $input2 =~ /gz$/;
				`cat $input2  | gzip >> $mergedFastq2` if $input2 !~ /gz$/;

				$Config->set_value( 'F', "$mergedFastq1:$mergedFastq2" );
			}
			else{
				$Config->set_value( 'F', $mergedFastq1 );
			}

			# Save FASTQ files (no longer in use)
			if( !$Config->get_value('SAVE_FASTQ') ){
				`rm -f $input1 2> /dev/null`;
				`rm -f $input2 2> /dev/null` if $input2;
			}
		}
		print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
	}
	$Config->set_value( 'I', 0 );
	$iType  = 'F';
	@inputs = split( ',', $Config->get_value($iType) );
	$iNum   = scalar @inputs;

	# Continue if BAM file or quality control on FASTQ file is requested
	unless( $Config->get_value('c') or $Config->get_value('q') ){
		exit;
	}
}

# Make the @bedFiles array recyclable for all BAM files
my $BedFiles = new BED_FILES( config => $Config );
$BedFiles->load_bed_files( $Config->get_value('B'), $iNum )
	if $Config->get_value('B');

my $DatFiles = new DAT_FILES( config => $Config );
$DatFiles->load_dat_files( $Config->get_value('D') )
	if $Config->get_value('D');

for( my $i = 1; $i <= $iNum; $i++ ){
	my $input  = $inputs[$i-1];
	print STDOUT "\n>> Processing input \'$iType\' ($i/$iNum)\n";

	#-------------------------------------------------------------------------------
	# Create FASTQ files from SRA files
	#-------------------------------------------------------------------------------
	$Config->set_value( 'QC', 0 ); # Quality control on raw reads flag

	if( $Config->get_value('I') ){
		print STDOUT "Processing SRA\n";
		print STDOUT "  > $input\n";

		$input = process_sra( $input, $Config );

		print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
	}

	#-------------------------------------------------------------------------------
	# Align reads to genome
	#-------------------------------------------------------------------------------
	$Config->set_value( 'DP', 0 ); # Remove duplicate reads flag

	if( $Config->get_value('F') ){
		print STDOUT "Processing FASTQ file\n";

		my $Fastq = load_fastq_file( $input, $Config );
		$input    = process_fastq_file( $Fastq, $Config );

		print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
	}
	# Continue if BAM files were requested
	next unless(
		$Config->get_value('B') or
		$Config->get_value('c')
	);

	#-------------------------------------------------------------------------------
	# Take BAM file as input
	#-------------------------------------------------------------------------------
	$Config->set_value( 'SP', 0 ); # Split BAM by chromosomes flag

	if( $Config->get_value('A') ){
		# Index and split BAM file by chromosomes
		print STDOUT "Processing BAM file\n";
		print STDOUT "  > $input\n";

		my $Alignment = process_bam_file( $input, $Config, $BedFiles );

		#---------------------------------------------------------------------------
		# Find allele-dependent behavior (ADBs) if requested
		#---------------------------------------------------------------------------
		if( $Config->get_value('d') ){
			print STDOUT "Finding allelic behavior\n";
			print STDOUT "  > $input\n";

			my $Genotyping = load_genotype( $Config, $BedFiles );
			my $success    = process_allelic_behavior(
				$Alignment,
				$Config,
				$Genotyping,
				$BedFiles,
				$DatFiles,
				$i,
			);

			if( ! $success ){
				print STDOUT "WARNING: Failed to generate DAT file\n";
				next;
			}
		}
		else{
			# Remove per chromosome BAM files (no longer used)
			`rm -f $outDir/chr*.bam 2> /dev/null`;

			# Save BAM file (no longer in use)
			if( !$Config->get_value('SAVE_BAM') ){
				my $input = $Alignment->get_file;
				`rm -f $input 2> /dev/null`;
			}
		}
		# Remove per chromosome BED files (no longer used)
		`rm -f $outDir/chr*.bed $outDir/*.bai 2> /dev/null`;

		print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
	}
	# Save DAT files state (it happens when all DAT files were successfully produced)
	$Config->set_value( 'D', 1 );
}
# Exit the program if only DAT files were requested
exit unless $Config->get_value('o');

# Annotate DAT files
#-------------------------------------------------------------------------------
if( $Config->get_value('D') ){
	my $datFiles = $DatFiles->get_files;

	# Second phase: obtain final results from all experiments
	print STDOUT "\n\e[0;36mINFO: Preparing results\e[0m\n";

	# Load ARS parameters
	my $ArScores = new ARS(
		file   => $Config->get_value('ARS_FILE'),
		outDir => $outDir,
		config => $Config,
	);
	my @sorted = sort{ $a cmp $b } keys %$datFiles;

	for my $mode ( @sorted ){
		my $dFiles = $datFiles->{$mode};
		# Make a selection based on given config
		print STDOUT "Merging posititions and calculating ARS ($mode)\n";
		my $adbFile = "$outDir/$mode\_results.adb";

		my $Postprocess = new POSTPROCESSING(
			file   => $adbFile,
			config => $Config,
		);
		$Postprocess->merge_positions( $dFiles );
		$Postprocess->add_means;
		$Postprocess->add_ars( $ArScores );
		$Postprocess->add_reference_bases;

		# Sort file in descending order by ARS values
		`head -n1 $adbFile > $adbFile.sorted`;
		`tail -n +2 $adbFile | sort -nrk15,15 -k1,1V -k2,2n >> $adbFile.sorted`;
		`mv -f $adbFile.sorted $adbFile`;

		print STDOUT "\e[0;32m[ DONE ]\e[0m\n";

		if( $Config->get_value('m') or $Config->get_value('n') ){
			print STDOUT "Postprocessing positions\n";

			$Postprocess->find_motif_matches( $Config->get_value('M') )
				if $Config->get_value('m');

			if( $Config->get_value('n') ){
				$Postprocess->annotate( $adbFile, $Config, $outDir );

				my $hitFile = $Postprocess->get_hitFile;
				$Postprocess->annotate( $hitFile, $Config, $outDir )
					if -s $hitFile;
			}
			print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
		}
	}
	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "\n\e[0;36mTotal time elapsed: $elapsed min\e[0m\n";
	print STDOUT "\e[0;32m[ DONE ]\e[0m\n";
}

# Remove $outDir/tmp directory
`rm -rf $outDir/tmp`;

exit;



#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

# SUBROUTINES
#-------------------------------------------------------------------------------

sub process_sra
{
	my $input  = shift;
	my $Config = shift;

	my $Fastq = new FASTQ(
		config => $Config,
	);
	$Fastq->generate( $input );

	my $fastq1 = $Fastq->get_file1;
	my $fastq2 = $Fastq->get_file2;

	if( $fastq2 ){
		$input = "$fastq1:$fastq2";
	}
	else{
		$input = $fastq1;
	}
	$Config->set_value( 'F', $input );

	return $input;
}

sub load_fastq_file
{
	my $input  = shift;
	my $Config = shift;

	my @jFiles = split( ':', $input );
	my $jFile1 = $jFiles[0];
	my $jFile2 = $jFiles[1];

	print STDOUT "  > $jFile1\n";
	print STDOUT "  > $jFile2\n" if $jFile2;

	my $Fastq = new FASTQ(
		config => $Config,
	);
	$Fastq->set_file1( $jFile1 );
	$Fastq->set_file2( $jFile2 ) if $jFile2;

	return $Fastq;
}

sub process_fastq_file
{
	my $Fastq  = shift;
	my $Config = shift;

	# Quality control on raw reads
	if( $Config->get_value('q') ){
		my $qcLogs = $Fastq->quality_control;

		if( ! $Config->get_value('COLORSPACE') ){
			$Fastq->trim_adapters( $qcLogs );
		}

		# Remove unused fastqc directory
		my $outDir = $Config->get_value('O');
		my $qcDir  = "$outDir/fastqc";
		`rm -rf $qcDir 2> /dev/null`;
	}

	# Continue if BAM files were requested
	unless( $Config->get_value('a') ){
		return 0;
	}

	# Align reads to genome
	my $Alignment = new ALIGNMENT(
		fastq  => $Fastq,
		config => $Config,
	);
	$Alignment->align_to_genome;

	# Sort BAM file
	$Alignment->sort_bam;

	# Remove duplicate reads
	if( !$Config->get_value('r') ){
		$Alignment->remove_duplicates;
		$Config->set_value( 'DP', 1 );
	}

	# Save FASTQ files (no longer in use)
	if( !$Config->get_value('SAVE_FASTQ') ){
		my $fastq1 = $Fastq->get_file1;
		my $fastq2 = $Fastq->get_file2;
		`rm -f $fastq1 2> /dev/null`;
		`rm -f $fastq2 2> /dev/null` if $fastq2;
	}
	my $input = $Alignment->get_file;
	$Config->set_value( 'A',  $input );

	return $input;
}

sub process_bam_file
{
	my $input    = shift;
	my $Config   = shift;
	my $BedFiles = shift;
	my $outDir   = $Config->get_value('O');
	my $bedFiles = $BedFiles->get_files;

	my $Alignment = new ALIGNMENT(
		file   => $input,
		config => $Config,
	);

	# Sort BAM file
	$Alignment->sort_bam;

	# Remove duplicate reads
	unless( $Config->get_value('r') or $Config->get_value('DP') ){
		$Alignment->remove_duplicates;
	}

	if( $bedFiles ){
		print STDOUT "BED files provided\n";
		print STDOUT "  > $input\n";
	}
#	elsif( $Config->get_value('c') and ! $bFiles ){
	elsif( $Config->get_value('c') ){
		# Split BAM file by chromosomes to allow counting reads under peaks
		$Alignment->split_bam_by_chr;
		$Config->set_value( 'SP', 1 );

		# Call peaks with MACS2
		print STDOUT "Call peaks from BAM file\n";
		print STDOUT "  > $input\n";

		my $Peaks = new PEAKS(
			bamFile => $Alignment->get_file,
			config  => $Config,
		);
		my $peakTypes = $Peaks->get_peak_types;

		my @sorted = sort{ $a cmp $b } keys %$peakTypes;
		for my $type ( @sorted ){
			$Peaks->call_peaks( $type );
			$Peaks->split_peaks_by_chr( $type );

			# Count reads under peaks using chrom-split BAM files
			$Peaks->count_reads_under_peak( $Alignment->get_chr_files, $type );

			# Save BED files
			my $bFile = $Peaks->get_file( $type );
			$BedFiles->add_files( $type, $bFile );
		}
	}

	return $Alignment;
}

sub load_genotype
{
	my $Config   = shift;
	my $BedFiles = shift;
	my $bedFiles = $BedFiles->get_files;

	# Filter SNPs within peaks and split by chromosome
	my $Genotyping = new GENOTYPING(
		config => $Config,
	);
	print STDOUT "  Loading genotype\n";

	$Genotyping->load_file( $Config->get_value('G') );

	if( $bedFiles and ! $Config->get_value('b') ){
		my $gStatus = $Genotyping->filter( $bedFiles );
		return 0 unless $gStatus;
	}

	return $Genotyping;
}

sub process_allelic_behavior
{
	my $Alignment  = shift;
	my $Config     = shift;
	my $Genotyping = shift;
	my $BedFiles   = shift;
	my $DatFiles   = shift;
	my $i          = shift;
	my $bamFile    = $Alignment->get_file;
	my $bedFiles   = $BedFiles->get_files;
	my @sorted     = sort{ $a cmp $b } keys %$bedFiles;

	for my $mode ( @sorted ){
		$Genotyping->split_gen_by_chr( $mode, $i-1 );
		my $genFiles = $Genotyping->get_chr_files;

		my $AD_behavior = new ADB(
			file   => $bamFile,
			config => $Config,
		);
		my $datFile = $AD_behavior->find_allelic_behavior(
			$Alignment,
			$genFiles,
			$mode
		);

		# Save BAM file (no longer in use)
		if( !$Config->get_value('SAVE_BAM') ){
			`rm -f $bamFile 2> /dev/null`;
		}

		# Save BED file (no longer in use)
		my $bedFile = $BedFiles->{$mode}[$i-1];

		if( $bedFile and ! $Config->get_value('SAVE_BED') ){
			`rm -f $bedFile 2> /dev/null`;
		}
		# Remove GEN files (no longer in use)
		`rm -f $outDir/*$mode.gen 2> /dev/null`;
		# Remove per chromosome DAT files (no longer in use)
		`rm -f $outDir/chr*.dat 2> /dev/null`;

		$datFile = 0 unless -s $datFile;
		$DatFiles->add_files( $mode, $datFile );
	}
	# Remove per chomosome BAM files (no longer in use)
	`rm -f $outDir/chr*.bam 2> /dev/null`;

	return 1;
}

#-------------------------------------------------------------------------------
package MESSAGES;
use warnings;
use strict;

sub die_with_usage
{
	my $progName = shift;
	my $version  = shift;
	my $created  = shift;
	my $modified = shift;

	die"
\e[0;33m================================================================================\e[0m

\e[0;33mMARIO (Measurement of Allelic Ratio Informatics Operator) pipeline\e[0m

\e[0;33mVersion:    $version\e[0m
\e[0;33mWritten by: Mario Pujato

\e[0;33m================================================================================\e[0m

\e[1;31mUse option -h for help\e[0m\n\n";
}

sub print_usage
{
	my $progName = shift;
	my $version  = shift;
	my $created  = shift;
	my $modified = shift;
	#getopts('I:S:1:2:B:D:b:p:C:h', \%options);
	my $examples = get_examples();

	print STDOUT "
\e[0;33m================================================================================\e[0m

\e[0;33mMARIO (Measurement of Allelic Ratio Informatics Operator) pipeline\e[0m

\e[0;33mVersion:    $version\e[0m
\e[0;33mWritten by: Mario Pujato

\e[0;33m================================================================================\e[0m

\e[1;31mUSAGE: $progName [options] <arguments>\e[0m

  [options]

    ARGUMENTS
      -O  Name of output folder
      -C  Configuration file (a sample file can be generated using option -y)

      -I  SRA IDs. Comma-separated list
            Based on these IDs, SRA files will be downloaded from NCBI
      -F  FASTQ files (paired-end reads experiments). Comma-separated list
            Paired-end reads experiments should be given in pairs, separated by \":\"
            (example: EXP1_FQ1:EXP1_FQ2,EXP2_FQ1:EXP2_FQ2,EXP3_FQ,EXP4_FQ...)
      -A  Alignment files (BAM format). Comma-separated list
            The file must be sorted
            Duplicate reads will be removed unless the -r option is set
      -D  DAT files. Comma-separated list
            This is the raw output of the MARIO pipeline (one per BAM file)
            Given these files, the pipeline will score and annotate the ADB
            predictions

      -X  Path to index files (STAR, HISAT2 and BOWTIE2 are supported)
            For BOWTIE2, add to the end of the index path the base name common
             to all the .bt2 files, like /path_to_index_files/hg19
            For HISAT2, add to the end of the index path the base name common
             to all the .ht2 files, like /path_to_index_files/hg19
            For STAR, nothing need to be added to the index path
      -G  Genotyping file containing ONLY heterozygous positions
            4-column format: CHR START END STATUS (TAB delimited)
		    The field STATUS takes values 0:genotyped and 1:imputed
      -p  (optional) Number of threads to use in parallelized routines
            (it defaults to use all available threads)

      -B  (optional) BED files. Comma-separated list
            (must match BAM files or will be recycled for all BAM files)
      -M  (optional) Motif files
            (provided as a single file listing motif files)

    SEQUENCE ALIGNER
      -s  Process RNA-seq experiment using the STAR aligner (34Gb o memory required!)
      -t  Process RNA-seq experiment using the HISAT2 aligner (low memory usage)
      -u  Process experiment using the BOWTIE2 aligner (low memory usage)
          BOWTIE2 is NOT suited for processing of RNA-seq experiments

    SWITCHES
      -h  This help message

      -i  Integrate/Concatenate multiple FASTQ files into one before alignment
            NOTE: It only works if either a list of SRA or FASTQ files is given
            This might be useful when a single GSM id points to multiple SRR ids,
            which are a single FASTQ file split into multiple SRA files

      -a  Align FASTQ files to genome
      -d  Find ADBs (generates DAT files -raw ADBs-)
      -o  Combine DAT files. Add Allelic Reproducibility Scores (ARS) and reference bases
      -n  Annotate DAT files

      -c  Call peaks from BAM file
      -q  Perform quality control of raw-reads (for each FASTQ file)

      -r  Retain duplicate reads in BAM output
            (the default behavior is to remove duplicate reads)
      -b  Do not require het-SNPs to fall within peaks
            (the default behavior id to require het-SNPs to fall within peaks)

      -x  Print pipeline scheme to the screen
      -y  Generate a default configuration file
      -z  Generate a default Allelic reproducibility score (ARS) file


$examples

\e[0;33m================================================================================\e[0m\n\n";

	return 1;
}

sub get_examples
{
	my $examples =
"\e[0;33mEXAMPLES:\e[0m

  Download and generate FASTQ files from SRA ID
    > MARIO -I SRR1608989 -C config_3.4.0.txt

  ChIP-seq experiments or similar:
  Align FASTQ reads to hg19 genome (starting from SRA ID)
    > MARIO -I SRR1608989 -C config_3.4.0.txt -uX path_to_BOWTIE2_aligner_index_files/hg19

  RNA-seq experiments:
  Align FASTQ reads to hg19 genome (starting from SRA ID)
    > MARIO -I SRR1608989 -C config_3.4.0.txt -sX path_to_STAR_aligner_index_files
    > MARIO -I SRR1608989 -C config_3.4.0.txt -tX path_to_HISAT2_aligner_index_files/hg19

  Align to genome using paired-end reads
    > MARIO -F SRR1_1.fq.gz:SRR1_2.fq.gz -C config_3.4.0.txt -sX path_to_STAR_aligner_index_files

  Align to genome using single and paired-end reads from different experiments
    > MARIO -F SRR1_1.fq.gz:SRR1_2.fq.gz,SRR2.fq.gz -C config_3.4.0.txt -sX path_to_STAR_aligner_index_files

  Call peaks on BAM files
    > MARIO -cA SRR1.bam,SRR2.bam -C config_3.4.0.txt

  Find ADBs from BAM files
    > MARIO -dA SRR1.bam,SRR2.bam -C config_3.4.0.txt -G path_to_genotyping_file/hetpos.txt";

	return $examples;
}

sub print_scheme
{
	my $progName = shift;
	my $version  = shift;
	my $examples = get_examples();

	print "
\e[0;33m================================================================================\e[0m

\e[0;33mScheme of the MARIO pipeline\e[0m

\e[0;33mVersion:    $version\e[0m
\e[0;33mWritten by: Mario Pujato

\e[0;33m================================================================================\e[0m

The pipeline can be used to start and/or generate any intermediate file in the scheme.

\e[1;32m+-------------------------------------------+\e[0m
\e[1;32m|                                           |\e[0m
\e[1;32m| +-----[I]       +-----[B]       +-----[G] |\e[0m
\e[1;32m| | SRAID |       |  BED  | ----> |  GEN  | |\e[0m
\e[1;32m| +-------+       +-------+  (b)  +-------+ |\e[0m
\e[1;32m|     |               ^               |     |\e[0m
\e[1;32m|     |               | (c)           |     |\e[0m
\e[1;32m|     v               |               v     |\e[0m
\e[1;32m| +-----[F]       +-----[A]       +-----[D] |       +=======+       +-------+\e[0m
\e[1;32m| | FASTQ | ----> |  BAM  | ----> |  DAT  | | ----> |  ADB  | <---- | ANNOT |\e[0m
\e[1;32m| +-------+  (a)  +-------+  (d)  +-------+ |  (o)  +=======+  (n)  +-------+\e[0m
\e[1;32m|    (q)              ^                     |           |\e[0m
\e[1;32m|                     |                     |           |\e[0m
\e[1;32m|                     |                     |           v\e[0m
\e[1;32m|                 +-----[X]                 |       +=======+       +-----[M]\e[0m
\e[1;32m|                 | INDEX |                 |       |  HIT  | <---- | MOTIF |\e[0m
\e[1;32m|                 +-------+                 |       +=======+       +-------+\e[0m
\e[1;32m|                                           |\e[0m
\e[1;32m+-------------------------------------------+\e[0m
\e[1;32m               BASIC FUNCTIONS                      ALLELE-DEPENDENT FUNCTIONS\e[0m

Input files:

-I  SRA ID (i.e. SRR1608989 )
-F  Fastq file (paired-end reads should be given separated with \":\", like: FQ1:FQ2)
-A  Alignment file (BAM format)
-D  DAT file (first ouput of the MARIO pipeline containing raw allelic counts)

Priority of input files:
  If multiple input files are privided (e.g.: SRA_ID, FASTQ and BAM files),
  the pipeline starts with the file with the highest priority.

  I<S<F<A<D (the DAT file has the highest priority)

-G  Genotyping file with heterozygous positions
-X  Index files for corresponding aligner (STAR, HISAT2 and BOWTIE2 are supported)
      For BOWTIE2, add to the end of the index path the base name common
       to all the .bt2 files, like /path_to_index_files/hg19
      For HISAT2, add to the end of the index path the base name common
       to all the .ht2 files, like /path_to_index_files/hg19
      For STAR, nothing need to be added to the index path
-C  Configuration file (can be generated with the -y option)
-M  (optional) File with a list of motifs (PWMs)

-a  Align FASTQ reads to the genome (generates BAM file)
-d  Find positions with Allele-Dependent Behavior (ADB). Generates DAT files
-o  Combine DAT files. Add Allelic Reproducibility Scores (ARS) and reference bases
-n  Annotate DAT files

-B  (optional) Peaks file in BED format
-O  Name of output folder (all files are saved here)
-c  Call peaks
-b  Do not require het-SNPs to fall within peaks
-p  Number of threads (default: use all available threads)
-q  Perform quality control on FASTQ files
-r  Keep duplicate reads
-s  Input data is RNA-seq (STAR alignment)
-t  Input data is RNA-seq (HISAT2 alignment)
-u  Input data is NOT RNA-seq (BOWTIE2 alignment)

Output files:
(BED) If the -c option is given, MACS2 called peaks are produced as a BED file.
      The BED file has 4 additional columns (6 through 9):
        6.  Number of reads under the peak
        7.  Peak width
        8.  RPKM, measured as the number of reads divided by the peak width,
             multiplied by 1,000,000 divided by the total number of reads under
             all peaks
        9.  TIER1 flag. If 1, the peak passed the minimum peak RPKM  requirement
        10. TIER2 flag. If 1, the peak passed the minimum peak width requirement
        11. TIER2 flag. If 1, the peak passed the minimum peak width requirement

(ADB) Allele-dependent behavior at each heterozygous positions, including
       reproducibility score (ARS) and annotations
(HIT) If motif files are given, the ADB file is further annotated with motif
       hits on each heterozygous position

NOTES:
      ADB and HIT Results are annotated using any available \"ANNO_#\" file
        specified in the configuration file.


$examples

\e[0;33m================================================================================\e[0m\n\n";

	return 1;
}

sub print_configuration_file
{
	my $version = shift;
	my $text =
"## COMMENTS
##-------------------------------------------------------------------------------
## Information about file location of necessary files

# Genotype files are located in:
# /home/mario/Databases/genotyping_data/hetSNPs
# /data/weirauchlab/databank/genomes/hg19/genotyping_data/hetSNPs # In the Cluster

# BOWTIE2 index files are located in:
# /home/mario/Databases/Hsap/aligner_indices/BOWTIE2
# /data/weirauchlab/databank/genomes/hg19/index/BOWTIE2 # In the Cluster

# HISAT2 index files are located in:
# /home/mario/Databases/Hsap/aligner_indices/BOWTIE2
# /data/weirauchlab/databank/genomes/hg19/index/BOWTIE2 # In the Cluster

# STAR index files (hets not masked) are located in:
# /home/mario/Databases/Hsap/aligner_indices/STAR/hg19
# /data/weirauchlab/databank/genomes/hg19/index/STAR/hg19 # In the Cluster

# Motif files (for ChIP-seq experiments) are located in:
# /home/mario/Databases/matrices/cisbp_matrices/motif_lists
# /data/weirauchlab/databank/genomes/hg19/cisbp_matrices/motif_lists # In the Cluster

# DB SNP 147 single file (use this file in case there is no available genotyping data) is located in:
# /home/mario/Databases/genotyping_data/hetSNPs/dbSNP147_single.txt
# /data/weirauchlab/databank/genomes/hg19/genotyping_data/hetSNPs/dbSNP147_single.txt # In the Cluster


## GENOME
##-------------------------------------------------------------------------------
## Specify the location of the genome in FASTA format (uncomment to activate)

# HUMAN genome
REFGEN_FILE  = /home/mario/Databases/Hsap/hg19/hg19.fa
#REFGEN_FILE  = /data/weirauchlab/databank/genomes/hg19/hg19.fa # In the Cluster

# MOUSE genome
#REFGEN_FILE  = /home/mario/Databases/Mmus/mm9/mm9.fa
#REFGEN_FILE  = /data/weirauchlab/databank/genomes/mm9/mm9.fa # In the Cluster

# ZEBRAFISH genome
#REFGEN_FILE  = /home/mario/Databases/danRer7/danRer7.fa
#REFGEN_FILE  = /data/weirauchlab/databank/genomes/danRer7/danRer7.fa # In the Cluster


## ANNOTATION
##-------------------------------------------------------------------------------
## BED files used to annotate final output
## Must have chromosome, start and end positions, followed by annotation fields
## Allelic positions will be annotated using all of the \"ANNO_#\" files given

ANNO_1 = /home/mario/Documents/CCHMC_postdoc/Projects/Allele_specific_variants/SDataB_VariantsUsedForEachPhenotype.bed
ANNO_2 = /home/mario/Databases/Hsap/hg19/hg19_exons_anno.bed

#ANNO_1 = /data/weirauchlab/databank/apps/MARIO/SDataB_VariantsUsedForEachPhenotype.bed # Cluster
#ANNO_2 = /data/weirauchlab/databank/apps/MARIO/hg19_exons_anno.bed # Cluster


## CHROMOSOMES
##-------------------------------------------------------------------------------
## Chromosomes to consider (comma-separated list)

# HUMAN
CHROMOSOMES = chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chr20,chr21,chr22,chrX,chrY

# MOUSE
#CHROMOSOMES = chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chrX,chrY

# ZEBRAFISH
#CHROMOSOMES = chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chr20,chr21,chr22,chr23,chr24,chr25


## CONFIGURATION PARAMENTERS
##-------------------------------------------------------------------------------

## ADB (Allele-Dependent Behavior) parameters

S_READS_CF  = 5     # Minimum number of reads (strong reads) to filter out ADB results
W_READS_CF  = 30    # Minimum number of reads (weak reads) to filter out ADB results when no genotyping information is available

## Motif searching parameters

SNP_PADD    = 20    # Number of base pairs to consider at each side of a SNP for motif searching
                    # Twice this value should encompass the whole length of virtually any motif
MOODS_PVAL  = 0.01  # P-value cutoff for the program MOODS (recommended: 0.01)
MIN_SCORE   = 0.5   # Minimum normalized motif match score to report (it applies to the strong allele)

## Optional parameters

PEAK_EXT    = 50    # Number of base pairs to extend called peaks on both sides
                    # MACS2 calls peaks using medium height or something similar
                    # This provides better representation of peak tails

## Peak calling options for MACS2
## Enter as many modes as you'd like, with the corresponding MACS2 options
## These lines should start with the word \"MODE\". After that you can choose a number or something else

# These modes are for HUMANs only as they have the option \"-g hs\"
# See the MACS2 documentation on how to specify other organisms
MODE1 = -g hs -q 0.01                                  # Narrow peak calls
MODE2 = -g hs -q 0.01 --broad                          # Broad peak calls
MODE3 = -g hs -q 0.01 --broad --nomodel --extsize 1000 # Broad peak (with no model) calls with peak size of 1000bp
MODE4 = -g hs -q 0.01 --broad --nomodel --extsize  500 # Broad peak (with no model) calls with peak size of 500bp


## SWITCHES
##-------------------------------------------------------------------------------
## Switches to save intermediate files
## It only affects intermediate files. Input files are never deleted
## 0 = DISCARD
## 1 = SAVE

SAVE_FASTQ = 1  # Save FASTQ files
SAVE_BAM   = 1  # Save alignment files (BAM format)
SAVE_BED   = 1  # Save peak files (BED format)


## EXTERNAL DEPENDENCIES
##-------------------------------------------------------------------------------
## Include full path if the program is not in the system's PATH variable

FASTQC     = fastqc
FASTQDUMP  = fastq-dump
#FASTQDUMP  = /data/weirauchlab/team/puj6ug/bin/fastq-dump  # In the Cluster
TRIMGALORE = trim_galore
CUTADAPT   = cutadapt
HISAT2     = hisat2
BOWTIE2    = bowtie2
STAR       = STAR
SAMTOOLS   = samtools # Version 1.3 or higher
BEDTOOLS   = bedtools
PICARD     = picard-tools MarkDuplicates
#PICARD     = java -Xmx6g -jar /usr/local/picard/1.89/jar/MarkDuplicates.jar  # In the Cluster
MACS2      = macs2
MOODS      = moods\n";

	my @lines = split( "\n", $text );
	open( OUT, ">CONFIG.txt" ) or
		die "ERROR: Could not write CONFIG.txt file\n";
	print OUT $text;
	close OUT;

	return 1;
}

sub print_ars_file
{
	open( OUT, ">ARS_table.txt" ) or
		die "ERROR: Could not write ARS file\n";

	print OUT "EXP	WS_RATIO	A	B
1	0.00	-0.84	0.15
1	0.10	-0.83	0.15
1	0.20	-0.81	0.15
1	0.30	-0.79	0.15
1	0.40	-0.73	0.15
1	0.50	-0.65	0.15
1	0.60	-0.55	0.15
1	0.70	-0.44	0.15
1	0.80	-0.36	0.15
1	0.90	-0.30	0.15
1	1.00	-0.26	0.15
2	0.00	-0.90	0.50
2	0.10	-0.89	0.50
2	0.20	-0.87	0.50
2	0.30	-0.84	0.50
2	0.40	-0.80	0.45
2	0.50	-0.75	0.40
2	0.60	-0.64	0.35
2	0.70	-0.52	0.35
2	0.80	-0.40	0.40
2	0.90	-0.33	0.45
2	1.00	-0.30	0.50
3	0.00	-0.98	1.25
3	0.10	-0.97	1.25
3	0.20	-0.94	1.25
3	0.30	-0.91	1.25
3	0.40	-0.86	1.25
3	0.50	-0.79	1.25
3	0.60	-0.69	1.25
3	0.70	-0.56	1.25
3	0.80	-0.45	1.25
3	0.90	-0.38	1.25
3	1.00	-0.36	1.25\n";

	return 1;
}

1;

#-------------------------------------------------------------------------------
package FILE;
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $file      = $arguments{'file'} or
		die "ERROR: Please provide an argument for 'file'\n";
	my $outDir    = $arguments{'outDir'} or
		die "ERROR: Please provide an argument for 'outDir'\n";

	my $self =
	{
		file       => $file,
		directory  => undef,
		base       => undef,
		extension  => undef,
		fileHandle => undef,
		outDir     => $outDir,
	};
	bless( $self, $class );

	$self->_parse_file_name;

	return $self;
}

sub file_exists
{
	my $self = shift;
	my $file = $self->{'file'};

	return 1 if -s $file;
	return 0;
}

sub get_file
{
	my $self = shift;
	return $self->{'file'};
}

sub get_directory
{
	my $self = shift;
	return $self->{'directory'};
}

sub get_name
{
	my $self = shift;
	my $base = $self->{'base'};
	my $ext  = $self->{'extension'};

	return "$base.$ext";
}

sub get_base
{
	my $self = shift;
	return $self->{'base'};
}

sub get_extension
{
	my $self = shift;
	return $self->{'extension'};
}

sub get_outDir
{
	my $self = shift;
	return $self->{'outDir'};
}

sub _parse_file_name
{
	my $self = shift;
	my $file = $self->{'file'};

	# Retrieve file name with full path
	$file    = `readlink -f $file`;
	chomp $file;

	# Extract full path, base name and extension
	$file    =~ /^(.*)\/(.+)\.(\w+)$/;
	my $dir  = $1;
	my $base = $2;
	my $ext  = $3;

	$self->{'directory'} = $dir;
	$self->{'base'}      = $base;
	$self->{'extension'} = $ext;

	return 1;
}

# Make a copy of the file to outDir and
# changes all attributes to point to this file
sub make_copy
{
	my $self   = shift;
	my $outDir = $self->get_outDir;
	my $file   = $self->get_file;
	my $name   = $self->get_name;

	`cp -f "$file" "$outDir/$name"`;

	$self->{'file'} = "$outDir/$name";
	$self->_parse_file_name;

	return 1;
}

sub set_file
{
	my $self = shift;
	my $file = shift;

	$self->{'file'} = $file;
	$self->_parse_file_name;

	return 1;
}

sub Open
{
	my $self = shift;
	my $file = $self->{'file'};

	open( my $FH, $file ) or
		die "ERROR: Could not open file $file\n";
	$self->{'fileHandle'} = $FH;

	return $FH;
}

sub Write
{
	my $self = shift;
	my $file = $self->{'file'};

	open( my $FH, ">$file" ) or
		die "ERROR: Could not open file $file\n";
	$self->{'fileHandle'} = $FH;

	return $FH;
}

sub Close
{
	my $self = shift;
	my $FH   = $self->{'fileHandle'};
	close $FH;

	return 1;
}

1;

#-------------------------------------------------------------------------------
package BED_FILES;
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";

	my $self  = {
		bed_files => undef, # {MODE#} = [files]
		config    => $Config,
	};
	bless( $self, $class );

	return $self;
}

sub get_files
{
	my $self     = shift;
	my $i        = shift;
	my $bedFiles = $self->{'bed_files'};

	if( $bedFiles ){
		return $bedFiles;
	}
	else{
		return 0;
	}
}

sub add_files
{
	my $self  = shift;
	my $bName = shift;
	my $bFile = shift;

	if( $self->{'bed_files'} ){
		my $bedFiles = $self->{'bed_files'};
		push( @{$bedFiles->{$bName}}, $bFile );
	}
	else{
		my %bedFiles;
		push( @{$bedFiles{$bName}}, $bFile );
		$self->{'bed_files'} = \%bedFiles;
	}

	return 1;
}

sub load_bed_files
{
	my $self   = shift;
	my $bLine  = shift;
	my $iNum   = shift;
	my $Config = $self->{'config'};
	my $modes  = $Config->get_value('MODES');
	my @modes  = sort{ $a cmp $b } keys %$modes;
	my %bedFiles;

	for my $bGroup ( split( ',', $bLine ) ){
		for my $mode ( @modes ){
			for my $bFile ( split( ':', $bGroup ) ){
				push( @{$bedFiles{$mode}}, $bFile );
			}
		}
	}
	my $bNum = scalar @{$bedFiles{$modes[0]}};

	if( $bNum < $iNum ){
		do{
			for my $mode ( keys %bedFiles ){
				push( @{$bedFiles{$mode}}, @{$bedFiles{$mode}} );
			}
			$bNum = scalar @{$bedFiles{$modes[0]}};
		}
		until( $bNum >= $iNum );
	}
	$self->{'bed_files'} = \%bedFiles;

	return 1;
}

1;

#-------------------------------------------------------------------------------
package DAT_FILES;
use warnings;
use strict;

sub new
{
	my $class = shift;
	my %arguments = @_;
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";

	my $self  = {
		dat_files => undef, # {MODE} = [files]
		config    => $Config,
	};
	bless( $self, $class );

	return $self;
}

sub get_files
{
	my $self     = shift;
	my $i        = shift;
	my $datFiles = $self->{'dat_files'};

	if( $datFiles ){
		return $datFiles;
	}
	else{
		return 0;
	}
}

sub add_files
{
	my $self  = shift;
	my $dName = shift;
	my $dFile = shift;

	if( $self->{'dat_files'} ){
		my $datFiles = $self->{'dat_files'};
		push( @{$datFiles->{$dName}}, $dFile );
	}
	else{
		my %datFiles;
		push( @{$datFiles{$dName}}, $dFile );
		$self->{'dat_files'} = \%datFiles;
	}

	return 1;
}

sub load_dat_files
{
	my $self   = shift;
	my $dLine  = shift;
	my $Config = $self->{'config'};
	my $modes  = $Config->get_value('MODES');
	my @modes;

	if( $modes ){
		@modes = sort{ $a cmp $b } keys %$modes;
	}
	else{
		push( @modes, 'MODE' );
	}
	my $exist  = $self->{'dat_files'} || 0;

	if( ! $exist ){
		my %datFiles;

		for my $dGroup ( split( ',', $dLine ) ){
			for my $mode ( @modes ){
				for my $dFile ( split( ':', $dGroup ) ){
					push( @{$datFiles{$mode}}, $dFile );
				}
			}
		}
		$self->{'dat_files'} = \%datFiles;
	}

	return 1;
}

1;

#-------------------------------------------------------------------------------
package CONFIGURATION;
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $options   = $arguments{'options'};
    my $outDir    = $arguments{'outDir'};

	my $self = {
		configuration => undef, # {name} = value
	};
	bless( $self, $class );

	# Get input with the highest priority
	$self->_configure( $options );

#	print STDOUT "\e[0;32m[ DONE ]\e[0m\n";

	return $self;
}

sub set_value
{
	my $self      = shift;
	my $confName  = shift;
	my $confValue = shift;
	my $config    = $self->{'configuration'};

	$config->{$confName} = $confValue;

	return 1;
}

sub get_value
{
	my $self     = shift;
	my $confName = shift;
	my $config   = $self->{'configuration'};

	if( defined $config->{$confName} ){
		return $config->{$confName};
	}
	else{
		return 0;
	}
}

sub _configure
{
	my $self    = shift;
	my $options = shift;
	my %include;

	# Process input priorities
	# options: 'D > A > F > S > I'
	#-------------------------
	my $inputFile = 'NONE';

	if( $options->{'D'} ){
		$inputFile      = 'D';
		$include{'D'}   = 1;
		$options->{'a'} = 1;
		$options->{'c'} = 1;
		$options->{'o'} = 1;
		$include{'a'}   = 1;
		$include{'c'}   = 1;
		$include{'o'}   = 1;
		_require_file( $options, 'D' );

		# Extract config from configuration file
		_load_configuration_file( $options );

		# Annotate positions
		# Linked to -o option if it finds at least one annotation file
		_require_n_group_options( $options, \%include );

		# Find motifs
		# Linked to -o option
		_require_M_group_options( $options, \%include )
			if $options->{'M'};
		_require_m_group_options( $options, \%include )
			if $options->{'m'};

		# Collapse files; add reference and ARS values
		_require_o_group_options( $options, \%include )
			if $options->{'o'};
	}
	elsif( $options->{'A'} ){
		$inputFile      = 'A';
		$include{'A'}   = 1;
		$options->{'a'} = 1;
		$include{'a'}   = 1;
		_require_file( $options, 'A' );

		# Include all files that may need to be saved
		$include{'SAVE_BAM'}   = 1;
		$include{'SAVE_BED'}   = 1;

		# Extract config from configuration file
		for my $opt ( keys %$options ){
			if( $opt =~ /[GBnMod]/ ){
				$options->{'d'} = 1;
			}
		}
		_load_configuration_file( $options );

		# if the SRA file is given, make sure it's not erased at the end!
		$options->{'SAVE_BAM'} = 1;

		# Call peaks
		if( $options->{'c'} ){
			# Linked to -a option
			_require_c_group_options( $options, \%include );
		}
		elsif( $options->{'B'} ){
			_require_b_group_options( $options, \%include );
		}
		_require_r_group_options( $options, \%include );

		# Check downstream analysis
		if( $options->{'d'} ){
			# If -G is given, assume allelic analysis is required
			_require_G_group_options( $options, \%include );

			# Annotate positions
			# Linked to -o option if it finds at least one annotation file
			_require_n_group_options( $options, \%include );

			# Find motifs
			# Linked to -o option
			_require_M_group_options( $options, \%include )
				if $options->{'M'};
			_require_m_group_options( $options, \%include )
				if $options->{'m'};

			# Collapse files; add reference and ARS values
			_require_o_group_options( $options, \%include )
				if $options->{'o'};

			# Perform allelic analysis and downstream tasks
			_require_d_group_options( $options, \%include );
		}
	}
	elsif( $options->{'F'} ){
		$inputFile    = 'F';
		$include{'F'} = 1;
		_require_file( $options, 'F' );

		# Include all files that may need to be saved
		$include{'SAVE_FASTQ'} = 1;
		$include{'SAVE_BAM'}   = 1;
		$include{'SAVE_BED'}   = 1;

		# Extract config from configuration file
		for my $opt ( keys %$options ){
			if( $opt =~ /[GBnMod]/ ){
				$options->{'d'} = 1;
			}
			elsif( $opt =~ /[stuXc]/ ){
				$options->{'a'} = 1;
			}
		}
		_load_configuration_file( $options );

		# if the SRA file is given, make sure it's not erased at the end!
		$options->{'SAVE_FASTQ'} = 1;

		# QC on raw reads
		# Linked to -f option
		_require_q_group_options( $options, \%include )
			if $options->{'q'};

		# Call peaks
		if( $options->{'c'} ){
			# Linked to -a option
			_require_c_group_options( $options, \%include );
		}
		elsif( $options->{'B'} ){
			_require_b_group_options( $options, \%include );
		}

		# Require a-group and/or c-group  options
		if( $options->{'a'} or $options->{'d'} ){
			_require_a_group_options( $options, \%include );
			_require_r_group_options( $options, \%include );
		}

		# Check downstream analysis
		if( $options->{'d'} ){
			# If -G is given, assume allelic analysis is required
			_require_G_group_options( $options, \%include );

			# Annotate positions
			# Linked to -o option if it finds at least one annotation file
			_require_n_group_options( $options, \%include );

			# Find motifs
			# Linked to -o option
			_require_M_group_options( $options, \%include )
				if $options->{'M'};
			_require_m_group_options( $options, \%include )
				if $options->{'m'};

			# Collapse files; add reference and ARS values
			_require_o_group_options( $options, \%include )
				if $options->{'o'};

			# Perform allelic analysis and downstream tasks
			_require_d_group_options( $options, \%include );
		}
	}
	elsif( $options->{'I'} ){
		$inputFile    = 'I';
		$include{'I'} = 1;

		# Include all files that may need to be saved
		$include{'SAVE_FASTQ'} = 1;
		$include{'SAVE_BAM'}   = 1;
		$include{'SAVE_BED'}   = 1;

		# Extract config from configuration file
		for my $opt ( keys %$options ){
			if( $opt =~ /[GBnMod]/ ){
				$options->{'d'} = 1;
			}
			elsif( $opt =~ /[stuXc]/ ){
				$options->{'a'} = 1;
			}
		}
		_load_configuration_file( $options );

		# QC on raw reads
		# Linked to -f option
		_require_q_group_options( $options, \%include )
			if $options->{'q'};

		# Extract FASTQ file from SRA file
		_require_program( $options, 'FASTQDUMP' );
		$include{'FASTQDUMP'} = 1;

		# Call peaks
		if( $options->{'c'} ){
			# Linked to -a option
			_require_c_group_options( $options, \%include );
		}
		elsif( $options->{'B'} ){
			_require_b_group_options( $options, \%include );
		}

		# Require a-group and/or c-group  options
		if( $options->{'a'} or $options->{'d'} ){
			_require_a_group_options( $options, \%include );
			_require_r_group_options( $options, \%include );
		}

		# Check downstream analysis
		if( $options->{'d'} ){
			# If -G is given, assume allelic analysis is required
			_require_G_group_options( $options, \%include );

			# Annotate positions
			# Linked to -o option if it finds at least one annotation file
			_require_n_group_options( $options, \%include );

			# Find motifs
			# Linked to -o option
			_require_M_group_options( $options, \%include )
				if $options->{'M'};
			_require_m_group_options( $options, \%include )
				if $options->{'m'};

			# Collapse files; add reference and ARS values
			_require_o_group_options( $options, \%include )
				if $options->{'o'};

			# Perform allelic analysis and downstream tasks
			_require_d_group_options( $options, \%include );
		}
	}
	#-------------------------
	$self->{'configuration'}{'iType'} = $inputFile;

	# Include common options
	# Available processors
	my $proc        = `nproc`; chomp $proc;
	$options->{'p'} = $options->{'p'} || $proc;
	$include{'p'}   = 1;
	# output directory
	$options->{'O'} = $options->{'O'} || '.';
	$include{'O'}   = 1;

	print STDOUT "\n\e[1;31mConfiguration:\e[0m\n\n";
	my @sorted = sort{ $a cmp $b } keys %$options;

	for my $conf ( @sorted ){

		if( $include{$conf} ){
			my $value = $options->{$conf};

			if( defined $value ){
				unless( $conf =~ /MODES|ANNO_FILES|[abcdfnqrst]/ ){
					printf STDOUT ( "%14s: %s\n", $conf, $value );
				}

				if( $conf =~ /MODES/ ){
					my @sorted = sort{ $a cmp $b } keys %$value;

					for my $mode ( @sorted ){
						my $subval = $value->{$mode};
						printf STDOUT ( "%14s: %s\n", "MACS2_$mode", $subval );
					}
				}

				if( $conf =~ /CHROMOSOMES/ ){
					my @values = split( ',', $value );
					$value     = \@values;
				}
				$self->{'configuration'}{$conf} = $value;
			}
			else{
				die "ERROR: A value for option \"$conf\" is missing\n";
			}
		}
	}
	print STDOUT "\n-------------------------------------------------------------------------------\n";

	return 1;
}

sub _load_configuration_file
{
	my $options = shift;
	my $version = $options->{'VERSION'};
	my $outDir  = $options->{'O'};
	$options->{'C'} = $options->{'C'} || "$outDir/CONFIG.txt";

	# Require option P
	_require_file( $options, 'C' );

	my $confFile = $options->{'C'};
	open( IN, $confFile ) or
		die "ERROR: Could not open configuration file \"$confFile\"\n";

	while( my $line = <IN> ){
		chomp $line;
		next if $line =~ /^\s*$/;
		next if $line =~ /^\s*#/;

		my $conf  = $line;
		my $value = $line;
		$conf     =~ s/\s*=.*?(.*)$//;
		$value    = $1;
		$value    =~ s/^\s*//;
		$value    =~ s/\s*#.*$//;

		if( $conf and defined $value ){
			$value          =~ s/\/+$//;
			$options{$conf} = $value;
		}
		else{
			print STDOUT "WARNING: Failed retrieving configuration line:\n  $line\n";
		}
	}
	close IN;

	return 1;
}

sub _require_file
{
	my $options = shift;
	my $conf    = shift;
	my $addon   = shift;

	if( $options->{$conf} ){
		my @split = split( /[,:]/, $options->{$conf} );

		for my $file ( @split ){
			$file = $options->{$conf} . $addon if $addon;

			# Check file is provided
			die "ERROR: Required file, \"$file\" in option \"$conf\", does not exist\n"
				if !-s $file;
		}
	}
	else{
		die "ERROR: Option \"$conf\" is missing\n";
	}
	return 1;
}

sub _require_program
{
	# Check program exists and it's functional
	my $options = shift;
	my $conf    = shift;
	my $status;

	if( $options->{$conf} ){
		$status = `type -a $options->{$conf} 2> /dev/null`;
	}
	else{
		die "ERROR: Option \"$conf\" is missing\n";
	}
	die "ERROR: Required command \"$conf\" not found\n"
		if !$status;

	return 1;
}

sub _require_q_group_options
{
	my $options = shift;
	my $include = shift;

	_require_program( $options, 'FASTQC' );
	_require_program( $options, 'TRIMGALORE' );
	_require_program( $options, 'CUTADAPT' );

	$include->{'FASTQC'}     = 1;
	$include->{'TRIMGALORE'} = 1;
	$include->{'CUTADAPT'}   = 1;
	$include->{'q'}          = 1;
}

sub _require_G_group_options
{
	my $options = shift;
	my $include = shift;

	_require_file( $options, 'G' );

	$include->{'G'} = 1;
	$include->{'b'} = 1;
	$options->{'d'} = 1;

	# Linked to -c or -B options
	unless( $options->{'b'} ){
		# Make sure call peaks is enabled or BED file is given
		unless( $options->{'c'} or $include->{'B'} ){
			die "ERROR: Missing options -c or -B\n";
		}
	}
}

sub _require_c_group_options
{
	my $options     = shift;
	my $include     = shift;
	$include->{'c'} = 1;
	$options->{'a'} = 1;
	$include->{'a'} = 1;

	_require_program( $options, 'MACS2' );
	_require_program( $options, 'SAMTOOLS' );

	# Save modes into hash
	my %modes;
	while( my( $key, $value ) = each %$options ){
		next unless $key =~ /^MODE/;
		$modes{$key} = $value;
	}

	$include->{'SAMTOOLS'}    = 1;
	$include->{'CHROMOSOMES'} = 1;
	$include->{'MACS2'}       = 1;
	$include->{'PEAK_EXT'}    = 1;
	$include->{'PEAK_RPKM'}   = 1;
	$include->{'PEAK_WIDTH'}  = 1;
	$include->{'MODES'}       = 1;

	$options->{'SAVE_BED'}    = 1;
	$options->{'MODES'}       = \%modes;
}

sub _require_b_group_options
{
	my $options = shift;
	my $include = shift;

	_require_file( $options, 'B' );

	$include->{'B'}        = 1;
	$options->{'SAVE_BED'} = 1;
}

sub _require_a_group_options
{
	my $options     = shift;
	my $include     = shift;
	$options->{'a'} = 1;
	$include->{'a'} = 1;

	_require_file( $options, 'REFGEN_FILE' );
	_require_program( $options, 'SAMTOOLS' );
	$include->{'SAMTOOLS'}    = 1;
	$include->{'REFGEN_FILE'} = 1;

	if( $options->{'s'} ){
		_require_file( $options, 'X', '/SAindex' );
		_require_program( $options, 'STAR' );
		$include->{'s'}       = 1;
		$include->{'STAR'}    = 1;
		$include->{'X'}       = 1;
	}
	elsif( $options->{'t'} ){
		_require_file( $options, 'X', '.1.ht2' );
		_require_program( $options, 'HISAT2' );
		$include->{'t'}       = 1;
		$include->{'HISAT2'}  = 1;
		$include->{'X'}       = 1;
	}
	elsif( $options->{'u'} ){
		_require_file( $options, 'X', '.1.bt2' );
		_require_program( $options, 'BOWTIE2' );
		$include->{'u'}       = 1;
		$include->{'BOWTIE2'} = 1;
		$include->{'X'}       = 1;
	}
	else{
		die "ERROR: Missing aligner option\n  Can be any of:\n    -s STAR\n    -t HISAT2\n    -u BOWTIE2\n";
	}
}

sub _require_r_group_options
{
	my $options = shift;
	my $include = shift;
	$include->{'r'} = 1;

	# Remove duplicate reads
	unless( $options->{'r'} ){
		_require_program( $options, 'PICARD' );
		$include->{'PICARD'}   = 1;
		$include->{'SAMTOOLS'} = 1;
	}
}

sub _require_M_group_options
{
	my $options = shift;
	my $include = shift;

	_require_file( $options, 'M' );
	$options->{'m'} = 1;
	$options->{'o'} = 1;
	$include->{'o'} = 1;
}

sub _require_m_group_options
{
	my $options     = shift;
	my $include     = shift;
	$include->{'m'} = 1;
	$include->{'M'} = 1;
	$options->{'o'} = 1;
	$include->{'o'} = 1;
	_require_file( $options, 'M' );
	_require_program( $options, 'MOODS' );

	$include->{'MOODS'}      = 1;
	$include->{'SNP_PADD'}   = 1;
	$include->{'MOODS_PVAL'} = 1;
	$include->{'MIN_SCORE'}  = 1;
}

sub _require_d_group_options
{
	my $options     = shift;
	my $include     = shift;
	$include->{'d'} = 1;

	_require_program( $options, 'SAMTOOLS' );
	_require_program( $options, 'BEDTOOLS' );

	$include->{'CHROMOSOMES'} = 1;
	$include->{'SAMTOOLS'}    = 1;
	$include->{'BEDTOOLS'}    = 1;
	$include->{'S_READS_CF'}  = 1;
	$include->{'W_READS_CF'}  = 1;
}

sub _require_o_group_options
{
	my $options = shift;
	my $include = shift;
	my $outDir  = $options->{'O'};

	MESSAGES::print_ars_file() if !-s "$outDir/ARS_table.txt";
	$options->{'ARS_FILE'} = "$outDir/ARS_table.txt";

	_require_file( $options, 'ARS_FILE' );
	_require_file( $options, 'REFGEN_FILE' );
	_require_program( $options, 'BEDTOOLS' );

	$include->{'REFGEN_FILE'} = 1;
	$include->{'BEDTOOLS'}    = 1;
	$include->{'ARS_FILE'}    = 1;
}

sub _require_n_group_options
{
	my $options = shift;
	my $include = shift;
	my @sorted  = sort{ $a cmp $b } keys %$options;
	my @annoFiles;

	for my $opt ( @sorted ){

		if( $opt =~ /ANNO_/ ){
			_require_file( $options, $opt );

			$include->{$opt} = 1;
			$options->{'n'}  = 1;
			$options->{'o'}  = 1;
			$include->{'n'}  = 1;
			$include->{'o'}  = 1;

			push( @annoFiles, $options->{$opt} );
		}
	}
	$options->{'ANNO_FILES'}  = \@annoFiles;
	$include->{'ANNO_FILES'}  = 1;
	$include->{'CHROMOSOMES'} = 1;
}

1;

#-------------------------------------------------------------------------------
package FASTQ;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";
	my $outDir    = $Config->get_value('O');

	# Constructor
	my $self = SUPER::new $class
	(
		file   => 'unavailable',
		outDir => $outDir,
	);
	$self->{'config'} = $Config;
	$self->{'file1'}  = undef;
	$self->{'file2'}  = undef;
	bless( $self, $class );

	return $self;
}

sub destroy
{
	my $self  = shift;
	my $file1 = $self->get_file1;
	my $file2 = $self->get_file2;

	print STDOUT "  Removing FASTQ files\n";

	`rm -f $file1`;
	`rm -f $file2` if $file2;

	return 1;
}

sub get_file1
{
	my $self = shift;
	return $self->{'file1'} || 0;
}

sub get_file2
{
	my $self = shift;
	return $self->{'file2'} || 0;
}

sub get_base1
{
	my $self = shift;
	my $base = $self->{'file1'};

	$base =~ s/^.*\///;
#	$base =~ s/(.*)_read[1]/$1/;
	$base =~ s/(.*).f(ast)*q(.gz)*/$1/;
#	$base =~ s/(.*)_[1]/$1/;

	return $base;
}

sub get_base2
{
	my $self = shift;
	my $base = $self->{'file2'} || 0;
	return 0 unless $base;

	$base =~ s/^.*\///;
#	$base =~ s/(.*)_read[2]/$1/;
	$base =~ s/(.*).f(ast)*q(.gz)*/$1/;
#	$base =~ s/(.*)_[2]/$1/;

	return $base;
}

sub set_file1
{
	my $self = shift;
	my $file = shift;
	$self->{'file1'} = $file;

	return 1;
}

sub set_file2
{
	my $self = shift;
	my $file = shift;
	$self->{'file2'} = $file;

	return 1;
}

sub quality_control
{
	my $self   = shift;
	my $Config = $self->{'config'};
	my $fastqc = $Config->get_value('FASTQC');
	my $outDir = $self->{'outDir'};
	print STDOUT "  Performing quality control ...\n";
	my $time0  = time;

	my @qcLogs;
	my @fastqs;
	my @bases;
	push( @fastqs, $self->get_file1 );
	push( @fastqs, $self->get_file2 );
	push( @bases,  $self->get_base1 );
	push( @bases,  $self->get_base2 );
	my $qcDir = "$outDir/fastqc";
	`mkdir -p $qcDir`;

	for( my $i = 0; $i < scalar @fastqs; $i++ ){
		my $fastq = $fastqs[$i];
		next unless $fastq;

		my $base  = $bases[$i];
		my $qcLog = "$outDir/$base\_fastqc.log";

		print STDOUT "    > $fastq\n";
		`$fastqc --extract -o $qcDir -f fastq $fastq 2> /dev/stdout | sed 's|^|        |' > /dev/stderr`;
		my $num = `ls $qcDir/$base*_fastqc/summary.txt | wc -l 2> /dev/null`;

		if( !$num ){
			print STDOUT "    Unable to QC reads!\n";
			return 0;
		}
		# Output report to STDOUT
		my $qcOut = `cut -f1,2 $qcDir/$base*_fastqc/summary.txt 2> /dev/null | sed 's|^|      |' | tail -n12`;
		print STDOUT "$qcOut"; # Report already contains new lines

		# Save to log file
		`echo $fastq > $qcLog && cut -f1,2 $qcDir/$base*_fastqc/summary.txt >> $qcLog`;

		# Detect if the FASTQ file is encoded in color space and flag it
		my $sequence = `zgrep -A1 "^@" $fastq | tail -n +2 | head -n1`; chomp $sequence;
		if( $sequence =~ /[0123]+/ ){
			$Config->set_value( 'COLORSPACE', 1 );
			print STDERR "    FASTQ sequences are encoded in color space\n";
		}

		push( @qcLogs, $qcLog );
	}
	# Move zipped fastqc directory
	`mv -f $qcDir/*.zip $outDir`;

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return \@qcLogs;
}

sub trim_adapters
{
    my $self   = shift;
    my $qcLogs = shift;

    # Test whether The Kmer content QC failed or not
    # If failed, trim possible adapter sequences
    my $fail   = 0;

    for my $qcLog ( @$qcLogs ){
        next unless $qcLog;

        open( IN, $qcLog ) or
            die "ERROR: Failed to open file $qcLog\n";

        while( my $line = <IN> ){
            if( $line =~ /FAIL\tAdapter Content/ ){
                print STDOUT "  Failed Adapter Content\n";
                $fail++;
            }
            if( $line =~ /FAIL\tPer base sequence quality/ ){
                print STDOUT "  Failed Per base sequence quality\n";
                $fail++;
            }
            if( $line =~ /FAIL\tPer sequence quality scores/ ){
                print STDOUT "  Failed Per sequence quality scores\n";
                $fail++;
            }
        }
        close IN;
    }
    return 1 unless $fail;

    # Kmer content QC failed! and alignment was requested
    # Take other neccessary inputs and trim adapter sequences
    my $Config     = $self->{'config'};
    return 1 unless $Config->get_value('a'); # Alignment requested

    my $fastq1     = $self->get_file1;
    my $fastq2     = $self->get_file2;
    my $base1      = $self->get_base1;
    my $base2      = $self->get_base2;

    print STDOUT "  Trimming sequences ...\n";
    my $time0 = time;

    if( $fail > 0 ){
        my $trimGalore = $Config->get_value('TRIMGALORE');
        my $cutadapt   = $Config->get_value('CUTADAPT');
        my $outDir     = $self->{'outDir'};

        # Treat paired-end reads
        if( $fastq2 ){
            my $base1a = $base1;
            $base1a    =~ s/^.*\///;
            my $base2a = $base2;
            $base2a    =~ s/^.*\///;

            # Run trim galore to remove adapters and low quality sequences or segments (for paired-end reads)
            `$trimGalore -o $outDir --path_to_cutadapt $cutadapt --paired $fastq1 $fastq2 2> /dev/null`;
            `mv -f $outDir/$base1a*_trimming_report.txt $outDir/$base1a\_trim.log`;

            if( $Config->get_value('I') ){
                # If FASTQ is an intermediate file, we can remove the orignal and leave the trimmed one
                `rm -f $fastq1 $fastq2`;
            }
			# Process the name of the trimmed file
			my $file1 = `ls $outDir\/$base1a*_val_1.fq*`; chomp $file1;
			my $file2 = `ls $outDir\/$base2a*_val_2.fq*`; chomp $file2;

			# Rename the "val_#" files to "trimmed"
			my $nFile1 = $file1;
			my $nFile2 = $file2;
			$nFile1    =~ s/val_1/trimmed/;
			$nFile2    =~ s/val_2/trimmed/;
			`mv -f $file1 $nFile1`;
			`mv -f $file2 $nFile2`;

			$self->set_file1( $nFile1 );
			$self->set_file2( $nFile2 );
        }
        # Treat single-end reads
        else{
            my $base = $base1;
            $base    =~ s/^.*\///;

            # Run trim galore to remove adapters and low quality sequences or segments
            `$trimGalore -o $outDir --path_to_cutadapt $cutadapt $fastq1 2> /dev/null`;
            `mv -f $outDir/$base*\_trimming_report.txt $outDir/$base\_trim.log`;

            if( $Config->get_value('I') ){
                # If FASTQ is an intermediate file, we can remove the orignal and leave the trimmed one
                `rm -f $fastq1`;
            }
			# Get the name of the trimmed FASTQ file and store it
			my $file = `ls $outDir\/$base*_trimmed.fq*`; chomp $file;
			$self->set_file1( $file );
        }
    }
    my $time1   = time;
    my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
    print STDOUT "  Time elapsed: $elapsed min\n";

    return 1;
}

sub generate
{
	my $self      = shift;
	my $sra       = shift;
	my $outDir    = $self->get_outDir;
	my $Config    = $self->{'config'};
	my $fastqDump = $Config->get_value('FASTQDUMP');
	my $numFiles  = 0;

	print STDOUT "  Generating FASTQ file ...\n";
	my $time0   = time;

	# Download SRA file via FTP
	my $valid;
	my $trial;
	my $limit = 5;

	my $sraFile = "$outDir/$sra.sra";
	do{
		$trial++;
		print STDOUT "    Downloading SRA file (trial $trial)\n";
		my( $sra6 ) = $sra =~ /(SRR\d{3})/;
		my $ftpSite = "ftp://ftp-trace.ncbi.nih.gov/sra/sra-instant/reads/ByRun/sra/SRR/$sra6/$sra";
		print "wget -cq -O $outDir/$sra.sra $ftpSite/$sra.sra\n";exit;
		`wget -cq -O $outDir/$sra.sra $ftpSite/$sra.sra`;

		# Check if SRA file was successfully downloaded
		my $checksum = `vdb-validate $sraFile 2>/dev/stdout | grep -oP "is consistent"`;
		chomp $checksum;

		if( $checksum eq 'is consistent' ){
			$valid = 1;
		}
		else{
			sleep 5;
		}
	}
	until( $valid or $trial == $limit );

	# Continue if SRA file is valid
	if( $valid ){
		print STDOUT "      MD5 checksum OK\n";
	}
	else{
		# Clean and throw error message
		`rm -f $sraFile`;
		die "ERROR: Failed downloading SRA file after $trial trials\n";
	}

	# Define FASTQ file names
	print STDOUT "    Trying with --split-files option\n";
	my $fastq1  = "$outDir/$sra\_1.fastq.gz";
	my $fastq2  = "$outDir/$sra\_2.fastq.gz";

	# Get FASTQ files
	if( !-s $fastq1 ){
		# -B option converts color-space to base-space
		`$fastqDump -B --split-files --gzip $sraFile -O $outDir 2> /dev/null`;

		die "ERROR: Failed to generate FASTQ files\n" unless -s $fastq1;
		`rm -f $sraFile`;
	}

	# Check for validity of FASTQ sequences after splitting
	my $status1 = check_fastq_file( $fastq1 );
	die "ERROR: Invalid FASTQ file 1\n"
		 unless $status1;
	my $status2 = check_fastq_file( $fastq2 );

	if( $status2 == 2 ){
		`rm -f $fastq1 $fastq2 2> /dev/null`;
		print STDOUT "    Trying without --split-files option\n";
		# Get FASTQ files
		`$fastqDump --gzip $sraFile -O $outDir 2> /dev/null`;
		$fastq1 =~ s/_1//;
	}

	$numFiles = `ls $outDir/*.fastq.gz 2> /dev/null | wc -l`;
	chomp $numFiles;

	if( $numFiles == 0 ){
		die "  Failed generating FASTQ files!\n";
	}
	$self->load_files( $fastq1, $fastq2 );

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub load_files
{
	my $self   = shift;
	my $fastq1 = shift;
	my $fastq2 = shift;

	$self->set_file1( $fastq1 );

	if( -s $fastq2 ){
		$self->set_file2( $fastq2 );
	}

	return 1;
}

sub check_fastq_file
{
	my $file   = shift;
	my $cutoff = 20; # Minimum number of base pairs that would make for a valid sequence

	# Get full path from generated FASTQ files
	my $fastq  = `readlink -f $file 2> /dev/null`;
	chomp $fastq;

	if( -s $fastq ){
		my $baseCount = `zcat $fastq | head -n2 | tail -n1 | wc -c`;
		chomp $baseCount;

		if( $baseCount > $cutoff ){
			# FASTQ file is good
			return 1;
		}
		else{
			# FASTQ file exists, but it's not valid. Therefore, should not use --split-files optio)
			return 2;
		}
	}
	else{
		# FASTQ file does not exist
		return 0;
	}
}

1;

#-------------------------------------------------------------------------------
package ALIGNMENT;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $bamFile   = $arguments{'file'};
    my $Fastq     = $arguments{'fastq'};
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";
	my $outDir    = $Config->get_value('O');
	my $chroms    = $Config->get_value('CHROMOSOMES');

	if( $Fastq ){
		my $base  = $Fastq->get_base1;
		$bamFile = "$outDir/$base.bam" unless $bamFile;
	}
	die "ERROR: Please provide an argument for 'file' or 'fastq'\n"
		unless $bamFile;

	# Constructor
	my $self = SUPER::new $class
	(
		file   => $bamFile,
		outDir => $outDir,
	);
	$self->{'config'}     = $Config;
	$self->{'fastq'}      = $Fastq || 0;
	$self->{'chrFiles'}   = undef;
	$self->{'readLength'} = undef;
	bless( $self, $class );

	return $self;
}

sub destroy_file
{
	my $self = shift;
	return 1;
}

sub destroy_files
{
	my $self  = shift;
	my $files = $self->{'chrFiles'};

	print STDOUT "  Removing BAM files split by chromosome\n";
	my @files = values %$files;
	`rm -f @files`;

	return 1;
}

sub get_readLength
{
	my $self = shift;
	return $self->{'readLength'};
}

sub get_file
{
	my $self = shift;
	return $self->{'file'};
}

sub get_chr_files
{
	my $self = shift;
	return $self->{'chrFiles'};
}

sub _get_chroms_from_fa
{
	my $fa_file = shift;
	my $Config  = shift;
	my @chroms  = `grep "^>" $fa_file | grep -oP "chr[\\d\\w]+" | grep -v chrM | sort -Vu`;
	chomp @chroms;
	$Config->set_value( 'CHROMOSOMES', \@chroms );

	return 1;
}

sub align_to_genome
{
	my $self     = shift;
	my $Fastq    = $self->{'fastq'};
	my $fastq1   = $Fastq->get_file1;
	my $fastq2   = $Fastq->get_file2;
	my $bamFile  = $self->{'file'};
	my $base     = $bamFile;
	$base        =~ s/^.*\///;
	$base        =~ s/\.bam$//;

	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value('SAMTOOLS');
	my $genome   = $Config->get_value('REFGEN_FILE');
	my $outDir   = $Config->get_value('O');
	my $index    = $Config->get_value('X');
	my $rnaseq   = $Config->get_value('r');
	my $proc     = $Config->get_value('p');

	my $gVersion = $genome;
	$gVersion    =~ s/^.*\///;
	$gVersion    =~ s/\.fa.*$//;

	my $time0      = time;
	my $numAligned = 0;
	my $totalReads = 0;

	# Detect paired-end or single-end reads
	my $pe_flag = 0;
	if( $fastq2 ){
		$pe_flag = 1;
		print STDOUT "  Aligning paired-end reads to $gVersion\n";
	}
	else{
		print STDOUT "  Aligning single-end reads to $gVersion\n";
	}

	# Check for gzipped files
	my $gz_flag = 0;
	if( $fastq1 =~ /\.gz/ ){
		print STDOUT "    FASTQ files are compressed\n";
		$gz_flag = 1;
	}

	# Use STAR with RNA-seq alignment (memory intensive! >32GB)
	if( $Config->get_value('s') ){
		my $star      = $Config->get_value('STAR');
		my $modifiers = "--outSAMtype BAM Unsorted --quantMode GeneCounts --outSAMmultNmax 1 --outMultimapperOrder Random";
		$modifiers   .= " --readFilesCommand zcat" if $gz_flag;
	 	my $out_base  = "--outFileNamePrefix $outDir/";
		my $fastqs    = $fastq1;
		$fastqs      .= " $fastq2" if $pe_flag;

		# Run STAR aligner
		`$star --runThreadN $proc $modifiers $out_base --genomeDir $index --readFilesIn $fastqs 2> /dev/null`;
		$totalReads  = `grep "Number of input reads"        $outDir/Log.final.out | cut -f2`; chomp $totalReads;
		$numAligned  = `grep "Uniquely mapped reads number" $outDir/Log.final.out | cut -f2`; chomp $numAligned;

		# Rename BAM file
		`mv -f $outDir/Aligned.out.bam $bamFile 2> /dev/null`;

		# Save relevant STAR output files
		`mv -f $outDir/Log.final.out $outDir/$base\_star.log 2> /dev/null`;
		`rm -rf $outDir/*.tab $outDir/_STARtmp $outDir/*.out 2> /dev/null`;
	}
	# Use HISAT2 to align RNA-seq
	elsif( $Config->get_value('t') ){
		my $hisat2    = $Config->get_value('HISAT2');
		my $log_file  = "$outDir/$base\_hisat2.log";
		my $modifiers = "--no-unal";
		my $fastqs    = "-U $fastq1";

		if( $pe_flag ){
			$modifiers .= " --no-discordant --no-mixed";
			$fastqs     = "-1 $fastq1 -2 $fastq2";
		}

		# Run HISAT2 aligner
		if( !-s $bamFile ){
			`$hisat2 -p $proc $modifiers -x $index $fastqs 2> $log_file | $samtools view -bS - > $bamFile 2> /dev/null`;
			$totalReads = `grep "reads; of these:" $log_file | sed 's|^ *||' | cut -d' ' -f1`; chomp $totalReads;
			$numAligned = `grep -A1 "exactly" $log_file | sed 's|^ *||' | cut -d' ' -f1 | paste -sd+ | bc`; chomp $numAligned;
		}
		else{
			$totalReads = `grep "reads; of these:" $log_file | sed 's|^ *||' | cut -d' ' -f1`; chomp $totalReads;
			$numAligned = `grep -A1 "exactly" $log_file | sed 's|^ *||' | cut -d' ' -f1 | paste -sd+ | bc`; chomp $numAligned;
		}
	}
	# Align with BOWTIE2
	elsif( $Config->get_value('u') ){
		my $bowtie2   = $Config->get_value('BOWTIE2');
		my $log_file  = "$outDir/$base\_bowtie2.log";

		my $modifiers = "--no-unal";
		my $fastqs    = "-U $fastq1";

		if( $pe_flag ){
			$modifiers .= " --no-discordant --no-mixed";
			$fastqs     = "-1 $fastq1 -2 $fastq2";
		}

		# Run BOWTIE2 aligner
		if( !-s $bamFile ){
			`$bowtie2 -p $proc $modifiers -x $index $fastqs 2> $log_file | $samtools view -bS - > $bamFile 2> /dev/null`;
			$totalReads = `grep "reads; of these:" $log_file | sed 's|^ *||' | cut -d' ' -f1`; chomp $totalReads;
			$numAligned = `grep -A1 "exactly" $log_file | sed 's|^ *||' | cut -d' ' -f1 | paste -sd+ | bc`; chomp $numAligned;
		}
		else{
			$totalReads = `grep "reads; of these:" $log_file | sed 's|^ *||' | cut -d' ' -f1`; chomp $totalReads;
			$numAligned = `grep -A1 "exactly" $log_file | sed 's|^ *||' | cut -d' ' -f1 | paste -sd+ | bc`; chomp $numAligned;
		}
	}

	if( $numAligned ){
		my $perc_aligned   = sprintf( "%.1f", $numAligned / $totalReads * 100 );
		print STDOUT "    Aligned reads = $numAligned ($perc_aligned%)\n";
		$self->{'aligned'} = $numAligned;
		$self->{'file'}    = $bamFile;
	}
	else{
		die "Reads aligned: 0 out of $totalReads\n";
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _count_aligned_reads
{
	my $bamFile    = shift;
	my $Config     = shift;
	my $samtools   = $Config->get_value('SAMTOOLS');
	my $numAligned = 0;

	$numAligned    = `$samtools view $bamFile | wc -l`;
	chomp $numAligned;

	return $numAligned;
}

sub sort_bam
{
	my $self     = shift;
	my $bamFile  = $self->{'file'};
	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value('SAMTOOLS');
	my $proc     = $Config->get_value('p');

	# Check if BAM file is sorted
	my $sorted = `$samtools view -H $bamFile | grep -oP "SO:\\w+"`;
	if( $sorted =~ /SO:coordinate/ ){
		print STDOUT "    BAM file is sorted\n";
		return 1;
	}

	print STDOUT "  Sorting BAM file ...\n";
	my $time0  = time;

	# Sort BAM file using samtools
	`$samtools sort -\@ $proc -o $bamFile.sort $bamFile > /dev/null 2>&1`;
	`mv $bamFile.sort $bamFile`;

	# Check again if BAM file is sorted
	$sorted    = `$samtools view -H $bamFile | grep -oP "SO:\\w+"`;
	if( $sorted =~ /SO:coordinate/ ){
		print STDOUT "    BAM file successfully sorted\n";
	}
	else{
		die "ERROR: Failed to sort BAM file!\n";
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub index_bam
{
	my $self     = shift;
	my $bamFile  = $self->{'file'};
	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value( 'SAMTOOLS' );

	print STDOUT "  Indexing BAM file $bamFile\n";
	my $time0    = time;

	if( !-s "$bamFile.bai" ){
		# Indexing
		`$samtools index $bamFile > /dev/null 2>&1`;
	}

	if( !-s "$bamFile.bai" ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub remove_duplicates
{
	my $self     = shift;
	my $bamFile  = $self->get_file;
	my $base     = $self->get_base;
	my $readLen  = $self->{'readLength'};
	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value('SAMTOOLS');
	my $outDir   = $Config->get_value('O');
	my $proc     = $Config->get_value('p');

	print STDOUT "  Removing duplicate reads ...\n";
	my $time0 = time;

	# Remove duplicate reads by chromosome, position and sequence
	my(
	 	$reads,
		$dups,
		$percDup,
	) = _remove_duplicate_reads( $self );
	die "    Failed!\n" if !$reads;

	my $perc    = sprintf( "%u", 100 - $percDup * 100 );
	my $dReads  = $reads - $dups;
	print STDOUT "    Unique reads returned = $dReads ($perc%)\n";
	$self->{'aligned_filt'} = $dReads;

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _remove_duplicate_reads
{
	my $self     = shift;
	my $bamFile  = $self->get_file;
	my $base     = $self->get_base;
	my $readLen  = $self->{'readLength'};
	my $Config   = $self->{'config'};
	my $picard   = $Config->get_value('PICARD');
	my $outDir   = $Config->get_value('O');
	my $bamDedup = "$outDir/$base\_dedup.bam";
	my $picLog   = "$outDir/$base\_picard.log";
	my $picErr   = "$outDir/$base\_picard_error.log";

	`$picard I=$bamFile REMOVE_DUPLICATES=true O=$bamDedup M=$picLog 2> $picErr`;
	die "    Failed!\n" unless -s $bamDedup;
	`mv -f $bamDedup $bamFile 2> /dev/null`;
	`rm -f $picErr`;

	my $result = `grep -A1 "^LIBRARY" $picLog | tail -1 | cut -f2,3,5,6,8`;
	chomp $result;

	# dups: number of single duplicate reads; pDups: number of paired duplicate reads
	my(
	 	$reads,
		$pReads,
		$dups,
		$pDups,
		$percDup,
	) = split( "\t", $result );

	if( $reads == 0 ){
		$reads = $pReads;
		$dups  = $pDups;
	}

	return(
	 	$reads,
		$dups,
		$percDup,
	);
}

sub get_length_of_largest_read
{
	my $self     = shift;
	my $bamFile  = $self->{'file'};
	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value('SAMTOOLS');

	# Get length of largest read
	print STDOUT "  Getting largest read length\n";

	my $readLength = `$samtools view $bamFile | head -n100000 | cut -f6 | grep -oP "^\\d+" | sort -nru | head -n1`;
	chomp $readLength;

	if( !$readLength ){
		print STDOUT "\n    Failed retrieving read length!\n";
		return 0;
	}
	$self->{'readLength'} = $readLength;

	print STDOUT "    Read length = $readLength bp\n";
	return 1;
}

sub split_bam_by_chr
{
	my $self     = shift;
	my $bamFile  = $self->get_file;
	my $base     = $self->get_base;
	my $Config   = $self->{'config'};
	my $samtools = $Config->get_value('SAMTOOLS');
	my $chroms   = $Config->get_value('CHROMOSOMES');
	my $outDir   = $Config->get_value('O');
	my $proc     = $Config->get_value('p');
	my %chrFiles;

	print STDOUT "  Split BAM file by chromosomes ...\n";
	my $time0    = time;

	# Indexing
	print STDOUT "    Indexing BAM file\n";
	`rm -f $bamFile.bai`;
	`$samtools index $bamFile > /dev/null 2>&1`;

	# Sort BAM file
	$self->sort_bam;

	for my $chr ( @$chroms ){
		my $chrBamFile = "$outDir/$chr\_$base.bam";

		# Split BAM file
		`$samtools view $bamFile $chr -b > $chrBamFile 2> /dev/null`
			if !-s $chrBamFile;

		# Count number of reads in this chromosome
		my $num_reads = _count_aligned_reads( $chrBamFile, $Config );
		my $answer    = "    No reads aligned to $chr\n";

		if( $num_reads ){
			$answer = "    Number of reads in $chr = $num_reads\n";
			$chrFiles{$chr} = $chrBamFile;
		}
		else{
			`rm -f $chrBamFile`;
		}
		print STDOUT $answer;
	}

	if( keys %chrFiles ){
		my $time1   = time;
		my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
		print STDOUT "  Time elapsed: $elapsed min\n";
		$self->{'chrFiles'} = \%chrFiles;

		return 1;
	}
	else{
		print STDOUT "  Failed splitting BAM file!\n";
		return 0;
	}
}

sub _get_chroms_from_bam
{
	my $bamFile  = shift;
	my $Config   = shift;
	my $samtools = $Config->get_value('SAMTOOLS');
	my @chroms   = `$samtools view -H $bamFile | grep "^\@SQ" | grep -v chrM | cut -f2 | cut -d: -f2`;
	chomp @chroms;
	$Config->set_value( 'CHROMOSOMES', \@chroms );

	return 1;
}

1;

#-------------------------------------------------------------------------------
package PEAKS;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $bamFile   = $arguments{'bamFile'} or
		die "ERROR: Please provide an argument for 'bamFile'\n";
    my $Config    = $arguments{'config'}  or
		die "ERROR: Please provide an argument for 'config'\n";
	my $outDir    = $Config->get_value('O');
	my $chroms    = $Config->get_value('CHROMOSOMES');

	# Peak types: {type}=mods
	my $peakTypes = $Config->get_value('MODES');

	my $base = $bamFile;
	$base    =~ s/^.*\///;
	$base    =~ s/.bam$//;
	my %peakFiles;
	my %chrFiles;

	while( my( $type, $mod ) = each %$peakTypes ){
		my $bedFile = "$outDir/$base\_$type.bed";
		$peakFiles{$type} = $bedFile;

		for my $chr ( @$chroms ){
			$chrFiles{$type}{$chr} = "$outDir/$chr\_$base\_$type.bed";
		}
	}

	# Constructor
	my $self = SUPER::new $class(
	 	file   => 'dummyFileName',
		outDir => $outDir,
	);
	$self->{'files'}     = \%peakFiles;
	$self->{'config'}    = $Config;
	$self->{'chrFiles'}  = \%chrFiles;
	$self->{'bamFile'}   = $bamFile;
	$self->{'peakTypes'} = $peakTypes;
	bless( $self, $class );

	return $self;
}

sub destroy_files
{
	my $self  = shift;
	my $files = $self->{'files'};

	print STDOUT "  Removing PEAK files\n";
	while( my( $type, $file ) = each %$files ){
		`rm -f $file`;
	}

	return 1;
}

sub destroy_chr_files
{
	my $self  = shift;
	my $files = $self->{'chrFiles'};

	print STDOUT "  Removing PEAK files split by chromosome\n";
	while( my( $type, $chrFiles ) = each %$files ){
		while( my( $chr, $file )  = each %$chrFiles ){
			`rm -f $file`;
		}
	}

	return 1;
}

sub get_file
{
	my $self = shift;
	my $type = shift;
	return $self->{'files'}{$type};
}

sub get_chr_files
{
	my $self = shift;
	my $type = shift;
	return $self->{'chrFiles'}{$type};
}

sub get_peak_types
{
	my $self = shift;
	return $self->{'peakTypes'};
}

sub call_peaks
{
	my $self      = shift;
	my $type      = shift;
	my $outDir    = $self->get_outDir;
	my $peakTypes = $self->{'peakTypes'};
	my $bamFile   = $self->{'bamFile'};

	my $Config   = $self->{'config'};
	my $chroms   = $Config->get_value('CHROMOSOMES');
	my $proc     = $Config->get_value('p');
	my $macs2    = $Config->get_value('MACS2');
	my $extend   = $Config->get_value('PEAK_EXT');

	print STDOUT "  Calling $type peaks ...\n";
	my $time0    = time;

	# Call peaks on BAM file using MACS2
	my $peakFile = $self->get_file( $type );

	# Get basename of peakFile
	my $logFile  = $peakFile;
	my $baseFile = $peakFile;
	$baseFile    =~ s/_$type.bed$/_macs2tmp/;
	$logFile     =~ s/.bed$/_macs2.log/;

	# Run MACS2
	my $mod = $peakTypes->{$type};
	`$macs2 callpeak $mod -t $bamFile -f BAM -n $baseFile 2> $logFile`;
	`rm -f $outDir/*macs2tmp*gapped*`;
	`mv -f $baseFile\_peaks.*Peak $peakFile`;

	# Remove unnecessary files form MACS2
	`rm -f $outDir/*macs2tmp*`;

	# Modify a few things in the BED file
	if( -s $peakFile ){
		# Eliminate path in BED file so it takes less space in disk
		`sed -i 's|$baseFile\_||' $peakFile`;
		# Extend peaks by $extend bp on both sides
		`awk '{print \$1,\$2-$extend,\$3+$extend,\$0}' OFS='\\t' $peakFile | cut -f1-3,7- > $peakFile.tmp`;
		`mv $peakFile.tmp $peakFile`;

		# Report number of peaks (if any)
		my $numPeaks = _get_number_of_peaks( $peakFile );
		my $answer   = "    No peaks found!\n";
		$answer      = "    Total number of peaks = $numPeaks\n" if $numPeaks;
		print STDOUT $answer;
	}
	else{
		print STDOUT "    Failed to call $type peaks!\n";
	}
	my $time1    = time;
	my $elapsed  = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub split_peaks_by_chr
{
	my $self      = shift;
	my $type      = shift;
	my $outDir    = $self->get_outDir;
	my $chrFiles  = $self->{'chrFiles'};
	my $Config    = $self->{'config'};
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my %chrFiles;

	print STDOUT "  Splitting peak file by chromosomes ...\n";
	my $time0 = time;

	# Split PEAK file by chromosomes
	my $peakFile = $self->{'files'}->{$type};

	if( !-s $peakFile ){
		print STDOUT "    No peak file $peakFile found!\n";
		return 0;
	}

	# Get basename of peakFile
#	my $baseFile = $peakFile;
#	$baseFile    =~ s/_$type.bed$//;

	# Get chrPeakFiles
	for my $chr ( @$chroms ){
		my $chrPeakFile = $chrFiles->{$type}{$chr};
		`grep -P "^$chr\\t" $peakFile > $chrPeakFile`;

		my $numPeaks = _get_number_of_peaks( $chrPeakFile );
		my $answer   = "    No peaks found for $chr\n";

		if( $numPeaks ){
			$answer = "    Number of peaks in $chr = $numPeaks\n";
		}
		else{
			`rm -f $chrPeakFile`;
		}
		print STDOUT $answer;
	}
	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed = $elapsed min\n";

	return 1;
}

sub _get_number_of_peaks
{
	my $peakFile = shift;
	my $numPeaks = 0;

	if( -s $peakFile ){
		$numPeaks = `cat $peakFile | wc -l`;
		chomp $numPeaks;
	}

	return $numPeaks;
}

sub count_reads_under_peak
{
	my $self      = shift;
	my $bamFiles  = shift;
	my $type      = shift;
	my $peakFile  = $self->get_file( $type );
	my $peakFiles = $self->get_chr_files( $type );
	my $outDir    = $self->get_outDir;
	my $peakBase  = $peakFile;
	$peakBase     =~ s/^.*\///;
	$peakBase     =~ s/\.bed$//;

	my $Config    = $self->{'config'};
	my $extend    = $Config->get_value('PEAK_EXT');
	my $minRpkm   = $Config->get_value('PEAK_RPKM');
	my $minWidth  = $Config->get_value('PEAK_WIDTH');
	my $minReads  = $Config->get_value('PEAK_READS');
	my $samtools  = $Config->get_value('SAMTOOLS');
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my $proc      = $Config->get_value('p');

	print STDOUT "  Counting reads under called peaks ...\n";
	my $time0     = time;

	my $pm = new Parallel::ForkManager( $proc );

	for my $chr ( @$chroms ){
		$pm->start and next;

		if( -s $peakFiles->{$chr} ){
			my $chrPeakFile  = $peakFiles->{$chr};
			my $chrBamFile   = $bamFiles->{$chr};
			my $chrCountFile = "$chrPeakFile.count";

			open( PEAK, "$chrPeakFile" ) or
				die "ERROR: Could not open file $chrPeakFile";
			open( BAM, "$samtools view $chrBamFile |" ) or
				die "ERROR: Could not open file $chrBamFile\n";
			open( OUT, ">$chrCountFile" ) or
				die "ERROR: Could not open file $chrCountFile\n";

			while( my $peak_line = <PEAK> ){
				chomp $peak_line;
				my(
					$p_chr,
					$p_start,
					$p_end,
					$p_id,
					$p_score,
					$p_strand,
					$p_foldchange,
					$p_pvalue,
					$p_qvalue,
					$p_summit,
				) = split( "\t", $peak_line );
				$p_summit      = $p_summit || 'NA';
				my $read_count = 0;
				my $state      = 0;

				do{
					my $bam_line = <BAM>;

					if( $bam_line ){
						chomp $bam_line;
						# SRR873824.24745869  0   chr22   16051210
						my @split   = split( "\t", $bam_line );

						# Filter by CIGAR line (exclude rare alignments)
						my $cigar   = $split[5];
						next if $cigar !~ /^(\d+[MSHIND])+$/;

						my $r_chr   = $split[2];
						my $r_start = $split[3];
						my $r_seq   = $split[9];
						my $r_len   = length $r_seq;
						my $r_end   = $r_start + $r_len - 1;

						if( $r_end >= $p_start ){
							if( $r_end >= $p_start and $r_start <= $p_end ){
								$read_count++;
							}
							else{
								my @p_data = (
									$p_chr,
									$p_start,
									$p_end,
									$p_id,
									$p_score,
									$p_strand,
									$p_foldchange,
									$p_pvalue,
									$p_qvalue,
									$p_summit,
								);
								$p_summit = $p_summit || 'NA';

								# CHR PEAK_START PEAK_END PEAK_ID PEAK_SUMMIT READ_COUNT
								if( $read_count ){
									push( @p_data, $read_count );
									print OUT join( "\t", @p_data ), "\n";
								}

								# Last peak considered if there is no more reads in the BAM file
								last if eof BAM;

								# Done with this peak, go to the next
								next;
							}
						}
					}
					else{
						$state = 1;
					}
				}
				until( $state == 1 );
			}
			close BAM;
			close PEAK;
			close OUT;

			# Rename the modified file
			if( -s $chrCountFile ){
				`mv $chrCountFile $chrPeakFile`;
			}
			else{
				print STDOUT "    Peak file for chromosome $chr not generated!\n";
				`rm -f $chrCountFile $chrPeakFile 2> /dev/null`;
			}
		}
		$pm->finish;
	}
	$pm->wait_all_children;

	# Count number of peaks in generated files
	my $chrCounts;
	for my $chr ( @$chroms ){
		if( $peakFiles->{$chr} ){
			if( -s $peakFiles->{$chr} ){
				my $chrPeakFile = $peakFiles->{$chr};
				my $rCount      = `cat $chrPeakFile | wc -l`; chomp $rCount;

				if( $rCount ){
					print STDOUT "    Number of counted peaks in $chr = $rCount\n";
					$chrCounts++;
				}
				else{
					print STDOUT "    No counted peaks in $chr\n";
				}
			}
		}
	}

	if( !$chrCounts ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	# Concatenate and sort BED files
	`cut -f1-11 $outDir/chr*_$peakBase.bed | sort -Vk1,1 -k2,2g > $peakFile`;

	# Remove spurious peaks (>= 300 bp in width AND >= 200 RPKM)
	my $totalCount = `cut -f11 $peakFile | paste -sd+ | bc`; chomp $totalCount;

	open( IN, $peakFile ) or
		die "ERROR: Could not open file $peakFile\n";
	my $tmpFile = "$peakFile.tmp";
	open( OUT, ">$tmpFile" ) or
		die "ERROR: Could not open file $tmpFile.tmp\n";

	while( my $line = <IN> ){
		chomp $line;
		my @split = split( "\t", $line );
		my $start = $split[1];
		my $end   = $split[2];
		my $reads = $split[10];
		my $width = ( $end - $start ) / 1000;
		my $rpkm  = sprintf( "%.4f", ( $reads / $width ) * ( 1000000 / $totalCount ) );

		my @output = (
			$line,
			$width * 1000,
			$rpkm,
		);
		print OUT join( "\t", @output ), "\n";
	}
	close IN;
	close OUT;
	`mv -f $tmpFile $peakFile`;

	# Report on the total number of reads in all peaks
	print STDOUT "    Total number of reads in peaks = $totalCount\n";

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

1;

#-------------------------------------------------------------------------------
package GENOTYPING;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";
	my $outDir    = $Config->get_value('O');
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my $gen_path  = $Config->get_value('GENOT_PATH');

	# Constructor
	my $self = SUPER::new $class
	(
	 	file   => "noFile",
		outDir => $outDir,
	);
	$self->{'config'}   = $Config;
	$self->{'chrFiles'} = undef;
	$self->{'filtered'} = undef;
	bless( $self, $class );

	return $self;
}

sub destroy_file
{
	my $self = shift;
	my $file = $self->get_file;

	print STDOUT "  Removing GENOTYPE file\n";
	`rm -f $file`;

	return 1;
}

sub destroy_files
{
	my $self  = shift;
	my $files = $self->{'chrFiles'};

	print STDOUT "  Removing temporary GENOTYPE files\n";
	my @files = values %$files;
	`rm -f @files`;

	return 1;
}

sub get_chr_files
{
	my $self = shift;
	return $self->{'chrFiles'} || 0;
}

sub get_filtered_files
{
	my $self = shift;
	return $self->{'filtered'};
}

sub load_file
{
	my $self    = shift;
	my $genFile = shift;
	my $Config  = $self->{'config'};

	print STDOUT "  Extracting GENOTYPE information ...\n";
	my $time0   = time;

	die "    Genotyping file not present or empty\n    $genFile\n"
		if !-s $genFile;

	my $numHets = `cat $genFile | wc -l`;
	chomp $numHets;

	if( $numHets ){
		print STDOUT "    Number of het-SNPs = $numHets\n";
	}
	else{
		die "    Failed retrieving het-SNPs\n";
	}
	$self->set_file( $genFile );

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub split_gen_by_chr
{
	my $self    = shift;
	my $mode    = shift;
	my $i       = shift;
	my $outDir  = $self->get_outDir;
	my $Config  = $self->{'config'};
	my $chroms  = $Config->get_value('CHROMOSOMES');
	my $gFiles  = $self->get_filtered_files;
	my $gFile   = $gFiles->{$mode}[$i];
	my $gBase   = $gFile;
	$gBase      =~ s/^.*\///;
	$gBase      =~ s/\.gen$//;
	my %chrFiles;

	print STDOUT "  Splitting GENOTYPE file into chromosomes ($mode:$gFile) ...\n";
	my $time0   = time;

	for my $chr ( @$chroms ){
		my $chrGenFile = "$outDir/$chr\_$gBase.gen";
		`grep -P "^$chr\t" $gFile > $chrGenFile`;

#		if( $gFile =~ /gz$/ ){
#			`zgrep -P "^$chr\t" $genFile > $chrGenFile`;
#		}
#		else{
#			`grep -P "^$chr\t" $gFile > $chrGenFile`;
#		}
		my $numHets = `cat $chrGenFile | wc -l`;
		chomp $numHets;

		if( $numHets ){
			print STDOUT "    Number of heterozygous positions in $chr = $numHets\n";
			$chrFiles{$chr} = $chrGenFile;
		}
		else{
			print STDOUT "    No heterozygous positions in $chr\n";
			`rm -f $chrGenFile`;
		}
	}

	if( ! keys %chrFiles ){
		print STDOUT "    Failed splitting genotyping file!\n";
		return 0;
	}
	$self->{'chrFiles'} = \%chrFiles;

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _get_chroms_from_gen
{
	my $genFile = shift;
	my $Config  = shift;
	my @chroms  = `cut -f1 $genFile | sort -Vu`;
	chomp @chroms;
	$Config->set_value( 'CHROMOSOMES', \@chroms );

	return 1;
}

sub filter
{
	my $self     = shift;
	my $bedFiles = shift;
	my $genFile  = $self->get_file;
	my $outDir   = $self->get_outDir;

	my $Config   = $self->{'config'};
	my $chroms   = $Config->get_value('CHROMOSOMES');
	my $bedtools = $Config->get_value('BEDTOOLS');
	# genFiles has the same structure as bedFiles ({mode}=[array_of_files])
	my %genFiles;

	my @sorted = sort{ $a cmp $b } keys %$bedFiles;

	for my $mode ( @sorted ){
		my $bFiles = $bedFiles->{$mode};

		for my $bFile ( @$bFiles ){
			my $base  = $bFile;
			$base     =~ s/^.*\///;
			$base     =~ s/.bed$//;
			my $time0 = time;

			print STDOUT "  Filtering GENOTYPE file with $mode:$bFile...\n";

			# Find SNPs within peaks
			my $tmpGen = "$outDir/filtered_$base.gen";
			`$bedtools intersect -a $genFile -b $bFile -wo | cut -f1-4 > $tmpGen`;

			my $numGen = `cat $tmpGen | wc -l`; chomp $numGen;
			if( $numGen ){
				print STDOUT "    Heterozygous positions within peaks = $numGen\n";
				push( @{$genFiles{$mode}}, $tmpGen );
			}
			else{
				print STDOUT "    No heterozygous positions within called peaks\n";
			}
		}
	}
	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	if( keys %genFiles == 0 ){
		return 0;
	}
	else{
		$self->{'filtered'} = \%genFiles;
		return 1;
	}
}

#-------------------------------------------------------------------------------
package ADB;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $adbFiles  = $arguments{'file'};
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";
	my $outDir    = $Config->get_value('O');

	# Constructor
	my $self = SUPER::new $class(
	 	file   => $adbFiles,
		outDir => $outDir,
	);
	$self->{'config'} = $Config;
	bless( $self, $class );

	return $self;
}

sub destroy_files
{
	my $self    = shift;
	my $datFile = $self->{'datFile'};
	my $aliFile = $self->{'aliFile'};

	 print STDOUT "  Removing DAT and ALI files split by chromosome\n";
	`rm -f $datFile $aliFile`;

	return 1;
}

sub get_datFile
{
	my $self = shift;
	return $self->{'datFile'} || 0;
}

sub get_aliFile
{
	my $self = shift;
	return $self->{'aliFile'} || 0;
}

sub find_allelic_behavior
{
	my $self      = shift;
	my $Alignment = shift;
	my $genFiles  = shift;
	my $mode      = shift;
	my $base      = $self->get_base;

	my $Config    = $self->{'config'};
	my $proc      = $Config->get_value('p');
	my $samtools  = $Config->get_value('SAMTOOLS');
	my $chroms    = $Config->get_value('CHROMOSOMES');
	my $sReadsCf  = $Config->get_value('S_READS_CF');
	my $wReadsCf  = $Config->get_value('W_READS_CF');
	my $outDir    = $Config->get_value('O');

	# Create directory to deposit ADB file
	my $datFile   = "$outDir/$base\_$mode.dat";

	# Split BAM file y chromosomes
	unless( $Config->get_value('SP') ){
		$Alignment->split_bam_by_chr;
	}
	my $bamFiles  = $Alignment->get_chr_files;

	my @header = (
		'CHR',
		'START',
		'END',
		'S_BASE',
		'W_BASE',
		'S_READS',
		'W_READS',
		'WS_RATIO',
		'SNP_STATUS',
	);

	print STDOUT "  Finding ADBs ...\n";
	my $time0 = time;

	# Find ADBs
	my $pm = new Parallel::ForkManager( $proc );

	for my $chr ( @$chroms ){
		$pm->start and next;
		my $adbNum = 0;

		my $chrBamFile = $bamFiles->{$chr};
		open( BAM, "$samtools view $chrBamFile |" ) or
			die "ERROR: Could not open BAM file $chrBamFile\n";
		my $chr_datFile = "$outDir/$chr\_$base.dat";
		open( DAT, ">$chr_datFile" ) or
			die "ERROR: Could not create file $chr_datFile\n";

		# Load genotyping information
		my %genotype;
		if( defined $genFiles ){
			die "ERROR: Missing genotyping information for chromosome $chr\n"
				if !$genFiles->{$chr};

			my $g_file = $genFiles->{$chr};
			open( GEN, $g_file ) or
				die "ERROR: Could not open genotype file: $g_file\n";

			while( my $line = <GEN> ){
				chomp $line;
				my( $chr, $start, $end, $val ) = split( "\t", $line );
				my $imp = 'g';
				$imp    = 'i' if $val;
				$genotype{$start} = $imp;
			}
		}

		# Print header
		print DAT join( "\t", @header ), "\n";

#		# BAM line column infomation
#		0 SEQ_ID    SRR873824.24745869
#		1 CODE      0
#		2 CHR       chr22
#		3 POS       16051210
#		4 -
#		5 CIGAR     36M
#		6 -
#		7 -
#		8 -
#		9 SEQUENCE  GTAAAATACTTTCATTTTCCTTCAGAGTCTGCTGTC

		# Process First BAM line
		my $bam_line    = <BAM>;
		my @bam         = split( "\t", $bam_line );
		my $start       = $bam[3];
		my @sorted_pos  = sort{ $a <=> $b } keys %genotype;
		my %pileups;

		while( my $gpos = shift @sorted_pos ){
			do{
				if( $gpos < $start ){
					# Write out results
					if( %pileups ){
						my $b_pileups = $pileups{$gpos};
						my @sorted    = sort{ $b_pileups->{$b} <=> $b_pileups->{$a} } keys %$b_pileups;
						my $s_base    = shift @sorted;
						my $sReads    = $b_pileups->{$s_base};

						if( $sReads >= $sReadsCf ){
							my $w_base  = shift @sorted         || 'N';
							my $wReads  = $b_pileups->{$w_base} ||  0;
							my $imp     = $genotype{$gpos};

							my $ws_ratio = $wReads / $sReads;
							print DAT "$chr\t$gpos\t$gpos\t$s_base\t$w_base\t$sReads\t$wReads\t$ws_ratio\t$imp\n";
						}
						undef %pileups;
					}
					next;
				}
				else{
					# Filter by CIGAR line (exclude rare alignments)
					if( $bam[5] =~ /^(\d+[MSHINDP])+$/ ){
						# Correct alternate sequence according to the CIGAR line
						my( $cseq, $clen ) = _correct_sequence( \@bam );
						my $end = $start + $clen - 1;

						if( $gpos <= $end ){
							# Get pileup
							my $base = substr( $cseq, $gpos - $start, 1 );
							$pileups{$gpos}{$base}++;
						}
					}
					# Process next BAM line
					$bam_line = <BAM>;
					@bam      = split( "\t", $bam_line );
					$start    = $bam[3];
				}
			}
			until( eof BAM );

			last if eof BAM;
		}
		close BAM;
		close DAT;

		# Remove chr BAM files (no longer used)
		`rm -f $chrBamFile 2> /dev/null`;

		$adbNum = `cat $chr_datFile | wc -l`;
		chomp $adbNum;
		$adbNum--; # Do not count the header
		print STDOUT "    Positions with ADB found for $chr = $adbNum\n";

		$pm->finish;
	}
	$pm->wait_all_children;

	# Print header on DAT file
	`head -n1 $outDir/chr*_$base.dat | grep -m1 "^CHR" > $datFile`;

	# Print body on DAT file
	`cat $outDir/chr*_$base.dat | grep -v "^CHR" | sort -Vk1,1 -k2,2n >> $datFile`;

	# Count total allelic binders there are in the DAT file
	my $numAllelic = `tail -n +2 $datFile | wc -l`;
	chomp $numAllelic;

	if( $numAllelic ){
		print STDOUT "    Total allelic binders = $numAllelic\n";
	}
	else{
		print STDOUT "    No allelic binders found!\n";
		`rm -f $datFile`;
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 0 unless -s $datFile;
	return $datFile;
}

sub _write_results
{
	my $DAT      = shift;
	my $pileups  = shift;
	my $gen_pos  = shift;
	my $srCutoff = shift;
	my $wrCutoff = shift;

	for my $chr ( keys %$pileups ){
		my $pileups_pos = $pileups->{$chr};

		for my $pos ( keys %$pileups_pos ){
			my $pileups_base = $pileups_pos->{$pos};
			my @sorted       = sort{ $pileups_base->{$b} <=> $pileups_base->{$a} } keys %$pileups_base;

			if( $gen_pos and $gen_pos->{$pos} ){
				# Genotyping information is used
				# Therefore, positions are filtered by genotype
				my $s_base   = shift @sorted;
				my $sReads  = $pileups_base->{$s_base};
				next if $sReads < $srCutoff;

				my $w_base   = shift @sorted || 'N';
				my $wReads  = $pileups_base->{$w_base} || 0;
				my $imp      = $gen_pos->{$pos};

				my $ws_ratio = $wReads / $sReads;
				print $DAT "$chr\t$pos\t$pos\t$s_base\t$w_base\t$sReads\t$wReads\t$ws_ratio\t$imp\n";
			}
		}
	}

	return 1;
}

sub _correct_sequence
{
#	BAM line column infomation
#	0 SEQ_ID    SRR873824.24745869
#	1 CODE      0
#	2 CHR       chr22
#	3 POS       16051210
#	4 -
#	5 CIGAR     36M
#	6 -
#	7 -
#	8 -
#	9 SEQUENCE  GTAAAATACTTTCATTTTCCTTCAGAGTCTGCTGTC
	my $bam   = shift;
	my $cigar = '' . $bam->[5];
	my $len   = length $bam->[9];
	my @num   = $cigar =~ /\d+/g;
	my @let   = $cigar =~ /\D/g;
	my $seq   = $bam->[9];

	# Relative position
	my $p = 0;
	my $clen;

	for( my $i = 0; $i < scalar @let; $i++ ){
		my $letter = $let[$i];
		my $number = $num[$i];

		if( $letter eq 'M' ){
			$p    += $number;
			$clen += $number;
		}
		elsif( $letter =~ /[SI]/ ){
			# Remove from sequence
			substr( $seq, $p, $number, '' );
		}
		elsif( $letter =~ /[NPD]/ ){
			# Insert '-'s
			my $m = '-' x $number;
			substr( $seq, $p, 0, $m );
			$p += $number;
		}
	}

	return( $seq, $clen );
}

1;

#-------------------------------------------------------------------------------
package ARS;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $arsFile   = $arguments{'file'}       or
		die "ERROR: Please provide an argument for 'file'\n";
    my $outDir    = $arguments{'outDir'}    or
		die "ERROR: Please provide an argument for 'outDir'\n";
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";

	# Constructor
	my $self = SUPER::new $class(
	 	file   => $arsFile,
		outDir => $outDir,
	);
	$self->{'ar_scores'} = undef;
	bless( $self, $class );

	# Load FDR data
	$self->_load_ars( $Config );

	return $self;
}

sub get_ars_data
{
	my $self = shift;
	return $self->{'ar_scores'};
}

sub _load_ars
{
	my $self    = shift;
	my $Config  = shift;
	my $arsFile = $self->get_file;
	my $IN      = $self->Open;

	# Remove header
	my $header = <$IN>;
	my %ars_data;

	while( my $line = <$IN> ){
		chomp $line;
		my(
		 	$exp,
		 	$ratio,
			$A,
			$B,
		) = split( "\t", $line );

		$ars_data{$exp}{$ratio} = [$A, $B];
	}
	$self->Close;
	$self->{'ar_scores'} = \%ars_data;

	return 1;
}

sub get_ars_score
{
	my $self  = shift;
	my $exp   = shift;
	my $ratio = shift;
	my $reads = shift;
	my $data  = $self->{'ar_scores'};
	my $step  = 0.1;
	my $ars;

	for( my $ratio0 = 0; $ratio0 <= 1; $ratio0 += $step ){
		my $ratio1 = sprintf( "%.2f", $ratio0 + $step );
		$ratio0    = sprintf( "%.2f", $ratio0 );

		if( $ratio >= $ratio0 && $ratio <= $ratio1 ){
			my $A0 = $data->{$exp}{$ratio0}[0];
			my $B0 = $data->{$exp}{$ratio0}[1];

			if( $ratio == $ratio0 ){
				$ars   = sprintf( "%.3f", $A0 / ( 1 + $B0 * $reads ) - $A0 );
			}
			elsif( $ratio == $ratio1 ){
				my $A1 = $data->{$exp}{$ratio1}[0];
				my $B1 = $data->{$exp}{$ratio1}[1];

				$ars   = sprintf( "%.3f", $A1 / ( 1 + $B1 * $reads ) - $A1 );
			}
			else{
				my $A1    = $data->{$exp}{$ratio1}[0];
				my $B1    = $data->{$exp}{$ratio1}[1];

				# Interpolate A and B values
				my $range = $ratio1 - $ratio0;
				my $diff  = $ratio  - $ratio0;
				my $A     = $A0 + ( $A1 - $A0 ) / $range * $diff;
				my $B     = $B0 + ( $B1 - $B0 ) / $range * $diff;

				# Apply logistic function with obtained config to get ARS
				$ars      = sprintf( "%.3f", $A / ( 1 + $B * $reads ) - $A );
			}
		}
	}

	return $ars;
}

1;

#-------------------------------------------------------------------------------
package STATISTICS;
use strict;
use warnings;
use POSIX qw(floor ceil);

sub new
{
	my $class     = shift;
	my %arguments = @_;
	my $data      = $arguments{'data'} or
		die "ERROR: Please provide an argument for 'data'\n";

	my $self = {
	 	data => $data,
		min  => undef,
		max  => undef,
	};
	bless( $self, $class );

	return $self;
}

sub min
{
	my $self = shift;
	my $data = $self->{'data'};
	
	if( $self->{'min'} ){
		return $self->{'min'};
	}
	else{
		my( $min, $max ) = _min_and_max( $data );
		$self->{'min'}   = $min;
		$self->{'max'}   = $max;
		return $min;
	}
}

sub max
{
	my $self = shift;
	my $data = $self->{'data'};
	
	if( $self->{'max'} ){
		return $self->{'max'};
	}
	else{
		my( $min, $max ) = _min_and_max( $data );
		$self->{'min'}   = $min;
		$self->{'max'}   = $max;
		return $max;
	}
}

## Calculates arithmetic mean given an array of numbers
#  Takes array reference
sub arithmetic_mean
{
	my $self = shift;
	my $data = $self->{'data'};
	my $mean = _mean( $data );
	return $mean;
}

# Minimum and maximum values
sub _min_and_max
{
	my $data = shift;

	# Sort values in ascending order
	my @sorted = sort{ $a <=> $b } @$data;
	my $min    = $sorted[0];
	my $max    = $sorted[-1];

	return( $min, $max );
}

sub _mean
{
	my $data = shift;
	my $n    = scalar @$data;
	my $sum  = 0;

	for my $value ( @$data ){
		$sum += $value;
	}
	return $sum / $n;
}

## Calculates standard deviation given an array of numbers and their mean
#  Takes array reference and mean
sub standard_deviation
{
	my $self = shift;
	my $data = $self->{'data'};
	my $mean = 0;

	if( $self->{'mean'} ){
		$mean = $self->{'mean'};
	}
	else{
		$mean = _mean( $data );
	}

	my $n   = scalar @$data;
	my $sum = 0;

	for my $value ( @$data ){
		my $sqdiff = ( $value - $mean ) ** 2;
		$sum    += $sqdiff;
	}

	my $stdev = sqrt( $sum / ( $n - 1 ) );

	return $stdev;
}

1;

#-------------------------------------------------------------------------------
package MOTIF;
use base 'FILE';
use warnings;
use strict;


sub new
{
    my $class     = shift;
    my %arguments = @_;
    my $file      = $arguments{'file'};
    my $outDir    = $arguments{'outDir'};
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";

	my $self = SUPER::new $class(
	 	file    => $file,
		outDir  => $outDir,
	);
    $self->{'motifMatrix'}    = undef; # Array of arrays defining the binding motif matrix
    $self->{'motif_length'}    = undef;
    $self->{'canonical_score'} = undef;
    $self->{'alphabet'}        = ['A','C','G','T'];
    bless( $self, $class );

	$self->_process_matrix_file;
    $self->_normalize;
	$self->_find_canonical_score( $Config );

    return $self;
}

sub get_canonical_score
{
	my $self = shift;
	return $self->{'canonical_score'};
}

sub _find_canonical_score
{
	my $self     = shift;
	my $Config   = shift;
	my $alphabet = $self->{'alphabet'};
	my $m_file   = $self->get_file;
	my $m_base   = $self->get_base;
	my $matrix   = $self->{'motifMatrix'};
	my $outDir   = $self->{'outDir'};
	my $fasta    = "$outDir/$m_base\_canonical.fa";

	# Find canonical sequence
	my $can_seq;

	for( my $j = 0; $j < scalar @{$matrix->[0]}; $j++ ){
		my $p_freq = 0;
		my $c_base; # Canonical base

		for( my $i = 0; $i < scalar @$alphabet; $i++ ){
			my $base = $alphabet->[$i];
			my $freq = $matrix->[$i][$j];

			if( $freq > $p_freq ){
				$c_base  = $base;
				$p_freq  = $freq;
			}
		}
		$can_seq .= $c_base;
	}
	open( OUT, ">$fasta" );
	print OUT  ">$m_base\n$can_seq\n";
	close OUT;

	# Find canonical score
	my $moods   = $Config->get_value( 'MOODS' );
	my $pval_cf = $Config->get_value( 'MOODS_PVAL' );

	# Create temporary matrix file without the first column that contains the bases
	my $cm_file = "$outDir/$m_base\_tmp.mat";
	`cut -d' ' -f2- "$m_file" > "$cm_file"`;

	# Run MOODS to get canonical score
	# MOODS produces zero-based positions in its output
	my $can_score = `$moods -f $pval_cf "$fasta" "$cm_file" 2>&1 | grep -vP \"^(cal|loa|Mat|Hit|Tot|\\n+)\" | awk \'NF\' | grep -P "^0\t" | cut -f2`;
	chomp $can_score;

	$self->{'canonical_score'} = $can_score;

	return 1;
}

sub get_motif_length
{
    my $self = shift;
    return $self->{'motif_length'};
}

sub get_forward_file
{
    my $self        = shift;
    my $motifMatrix = $self->{'motifMatrix'};
    my $outDir      = $self->{'outDir'};
    my $file_base   = $self->get_base;
	my $file_name   = "$outDir/$file_base\_fw.mat";

	my $Matfile = new FILE(
	 	file   => $file_name,
		outDir => $outDir,
	);

    _print_motifMatrix(
		$motifMatrix,
		$Matfile,
	);

    die "ERROR: Failed generating forward motif file $file_name\n" 
		if !-s "$file_name";

    return $Matfile->get_file;
}

sub get_reverse_file
{
    my $self        = shift;
    my $motifMatrix = $self->{'motifMatrix'};
    my $outDir      = $self->{'outDir'};
    my $file_base   = $self->get_base;
	my $file_name   = "$outDir/$file_base\_rc.mat";

    $motifMatrix    = _reverse_matrix( $motifMatrix );

	my $Matfile = new FILE(
	 	file    => $file_name,
		outDir  => $outDir,
	);

    _print_motifMatrix(
		$motifMatrix,
		$Matfile,
	);

    die "ERROR: Failed generating reverse motif file $file_name\n" 
		if !-s "$file_name";

    return $Matfile->get_file;
}

sub _reverse_matrix
{
    my $matrix = shift;
	my $width  = scalar @$matrix;
	my @rc_matrix;

    for( my $i = $width - 1; $i >= 0; $i-- ){
        my @frequencies = reverse @{$matrix->[$i]};
        push( @rc_matrix, \@frequencies );
    }

	return \@rc_matrix;
}

sub _print_motifMatrix
{
    my $motifMatrix = shift;
    my $File        = shift;
	my $OUT         = $File->Write;

    for( my $i = 0; $i < scalar @$motifMatrix; $i++ ){
        my $frequencies = $motifMatrix->[$i];
        print $OUT join( "\t", @$frequencies ), "\n";
	}

    $File->Close;

    return 1;
}

sub _process_matrix_file
{
    my $self   = shift;
	my $format = _check_transfac_format( $self->get_file );

	if( $format =~ /^Pos/ ){
		_transfac_to_jaspar( $self );
	}
	my $matrix = _process_jaspar_format( $self );

	die "ERROR: Failed processing matrix file $self->get_file\n" 
		if !$matrix;

	$self->{'motifMatrix'} = $matrix;
	$self->{'motif_length'} = scalar @{$matrix->[0]};

	return 1;
}

sub print_matrix
{
	my $self      = shift;
    my $matrix    = $self->{'motifMatrix'};
    my $alphabet  = $self->{'alphabet'};
    my $file_base = $self->get_base;

	print "MATRIX for $file_base\n";

    for( my $i = 0; $i < scalar @$alphabet; $i++ ){
        my $frequencies = $matrix->[$i];
        my $base        = $alphabet->[$i];

        print "$base: ", join( ' ', @$frequencies ), "\n";
    }

    return 1;
}

sub _process_jaspar_format
{
	my $self         = shift;
	my $alphabet     = $self->{'alphabet'};
	my @dummy_column = ( 0.23, 0.27, 0.24, 0.26 );

	my $IN = $self->Open;
    my %tmp_matrix;

    while( my $line = <$IN> ){
		chomp $line;
        my( $base, @frequencies ) = split( /\s+|\t+/, $line );

		# Remove anything but the 4 letters ACGT
        $base =~ s/[^ACGT]//g;

		my $matrix_length  = scalar @frequencies;

		if( $matrix_length < 7 ){
			my $number_add = 7 - $matrix_length;
			my $dummy_freq = shift @dummy_column;

			for( my $i = 0; $i < $number_add; $i++ ){
				push( @frequencies, $dummy_freq );
			}

			$tmp_matrix{$base} = \@frequencies;
		}
		else{
			$tmp_matrix{$base} = \@frequencies;
		}
    }

	$self->Close;

    my @motifMatrix;

    foreach my $base ( @$alphabet ){
        my $frequencies = $tmp_matrix{$base};
        push( @motifMatrix, $frequencies );
    }

    return \@motifMatrix;
}

sub _check_transfac_format
{
	my $file   = shift;
	my $header = `grep -P \"^Pos\t[ACGT]\" "$file"`;
	chomp $header;

	return $header;
}

sub _transfac_to_jaspar
{
    my $self     = shift;
	my $file     = $self->get_file;
    my @alphabet = ( 'A', 'C', 'G', 'T' );

    my %transfac;

    open( IN, $file ) or die "ERROR: Could not open file $file\n";
    my @data   = <IN>;
    close IN;

	my $header = shift @data;
	chomp $header;
    my @fields = split( /\s+|\t+/, $header );

    for( my $i = 0; $i < scalar @data; $i++ ){
        my $line  = $data[$i];
        chomp $line;

        my @split = split( /\s+|\t+/, $line );

        for( my $f = 0; $f < scalar @split; $f++ ){
			my $field = $fields[$f];
			my $value = $split[$f];
			$value    = sprintf( "%.3f", $value );
            push( @{$transfac{$field}}, $value );
        }
    }

    # Convert to JASPAR format
    my @jaspar;

    foreach my $base ( @alphabet ){
        if( $transfac{$base} ){
            my $line = "$base: " . join( ' ', @{$transfac{$base}} );
            push( @jaspar, $line );
        }
    }

	my $outDir = $self->get_outDir;
	my $base   = $self->get_base;
	my $jaspar = "$outDir/$base.mat";
	open( OUT, ">$jaspar" ) or
		die "ERROR: Could not create motif file $jaspar\n";
    print OUT join( "\n", @jaspar ), "\n";
	close OUT;
	$self->set_file( $jaspar );

    return 1;
}

sub _normalize
{
	my $self        = shift;
	my $motifMatrix = $self->{'motifMatrix'};

	# Get column sums
	my @col_sums;

	for my $frequencies ( @$motifMatrix ){
		for( my $i = 0; $i < scalar @$frequencies; $i++ ){
			my $freq       = $frequencies->[$i];
			$col_sums[$i] += $freq;
		}
	}

	# Normalize frequencies
	for my $frequencies ( @$motifMatrix ){
		for( my $i = 0; $i < scalar @$frequencies; $i++ ){
			$frequencies->[$i] /= $col_sums[$i];
			$frequencies->[$i]  = sprintf( "%.4f", $frequencies->[$i] );
		}
	}

	return 1;
}

1;

#-------------------------------------------------------------------------------
package POSTPROCESSING;
use base 'FILE';
use warnings;
use strict;

sub new
{
	my $class     = shift;
	my %arguments = @_;
    my $file      = $arguments{'file'}   or
		die "ERROR: Please provide an argument for 'file'\n";
    my $Config    = $arguments{'config'} or
		die "ERROR: Please provide an argument for 'config'\n";
	my $outDir    = $Config->get_value('O');
	my $hitFile   = $file;
	$hitFile      =~ s/\.adb$/.hit/;

	# Constructor
	my $self = SUPER::new $class(
	 	file   => $file,
		outDir => $outDir,
	);
	$self->{'config'}  = $Config;
	$self->{'hitFile'} = $hitFile;
	bless( $self, $class );

	return $self;
}

sub get_hitFile
{
	my $self = shift;
	return $self->{'hitFile'};
}

sub merge_positions
{
	my $self  = shift;
	my $files = shift;

	# Merge ADB data
	my $iFile = shift @$files;
	open( ADB1, $iFile ) or
		die "ERROR: Could not open file $iFile\n";

	print STDOUT "  Merging positions ...\n";
	my $time0 = time;

	# Remove header
	my $header1 = <ADB1>;
	chomp $header1;
	my @data1   = <ADB1>;
	chomp @data1;
	close ADB1;

	for my $iFile ( @$files ){
		open( ADB2, $iFile ) or
			die "ERROR: Could not open file $iFile\n";
		# Remove header
		my $header2 = <ADB2>;
		my @data2   = <ADB2>;
		chomp @data2;
		close ADB2;
		@data1      = _merge( \@data1, \@data2 );
	}

	# Write merged data to file
	my $OUT = $self->Write;
	print $OUT "$header1\n";

	for my $line ( @data1 ){
		print $OUT "$line\n";
	}
	$self->Close;

	# Sort positions
	my $mFile = $self->get_file;
	`sort -Vk1,1 -k2,2n $mFile > $mFile.tmp && mv -f $mFile.tmp $mFile`;

	my $num = scalar @data1;

	if( $num > 1 ){
		print STDOUT "    Total number of ADB positions = $num\n";
	}
	else{
		print STDOUT "    Failed to merge ADB positions!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _merge
{
	my $data1 = shift;
	my $data2 = shift;
	my %exist;

	for my $line1 ( @$data1 ){
		my @split = split( "\t", $line1 );
		my $chr   = $split[0];
		my $start = $split[1];

		$exist{"$chr-$start"} = $line1;
	}

	# Find overlap with data2
	my @data;

	for my $line2 ( @$data2 ){
		my @split2 = split( "\t", $line2 );
		my $chr    = $split2[0];
		my $start  = $split2[1];
		my $end    = $split2[2];

		if( $exist{"$chr-$start"} ){
			my $line1  = $exist{"$chr-$start"};
			my @split1 = split( "\t", $line1 );

			my @array  = (
				$chr,                      # CHR
				$start,                    # START
				$end,                      # END
				"$split1[3],$split2[3]",   # S_BASE
				"$split1[4],$split2[4]",   # W_BASE
				"$split1[5],$split2[5]",   # S_READS
				"$split1[6],$split2[6]",   # W_READS
				"$split1[7],$split2[7]",   # WS_RATIO
				$split1[8],                # SNP_STATUS (same position always has same genotyping status)
			);
			my $line = join( "\t", @array );
			push( @data, $line );
			delete $exist{"$chr-$start"};
		}
		else{
			push( @data, $line2 );
		}
	}

	# Get remaining lines from data1
	while( my( $key, $line1 ) = each %exist ){
		push( @data, $line1 );
	}

	return @data;
}

sub add_means
{
	my $self      = shift;
	my $procFile  = $self->get_file;
	my $outDir    = $self->get_outDir;
	my $Config    = $self->{'config'};
	my $statsFile = "$procFile.stats";

	print STDOUT "  Adding statistics ...\n";
	my $time0  = time;

	# Print header
	my $PROC   = $self->Open;
	open( OUT, ">$statsFile" );
	my $header = <$PROC>;
	chomp $header;
	my @header = split( "\t", $header );
	my @hStats = (
		'S_READS_AVG',
		'W_READS_AVG',
		'WS_RATIO_AVG',
	);
	my @hOut   = ( @header, @hStats );
	print OUT join( "\t", @hOut ), "\n";
	my $num;

	while( my $line = <$PROC> ){
		chomp $line;
		my @split = split( "\t", $line );
		my @stats;

		for my $field ( @split ){

			if( $field =~ /\d,\d/ ){
				my @data = split( ',', $field );
				my $Stat = new STATISTICS(
					data => \@data,
				);
				push( @stats, $Stat->arithmetic_mean );
			}
		}

		if( @stats ){
			my @proc = ( @split, @stats );
			print OUT join( "\t", @proc ), "\n";
		}
		else{
			my @proc = ( @split, $split[5], $split[6], $split[7] );
			print OUT join( "\t", @proc ), "\n";
		}
		$num++;
	}
	$self->Close;
	close OUT;

	if( $num > 1 and -s $statsFile ){
		print STDOUT "    Number of processed lines = $num\n";
		`mv $statsFile $procFile`;
	}
	else{
		print STDOUT "    Failed to calculate statistics!\n";
		`rm -f $statsFile`;
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub add_ars
{
	my $self     = shift;
	my $ArScores = shift;
	my $procFile = $self->get_file;
	my $Config   = $self->{'config'};
	my $procTmp  = "$procFile.tmp";

	print STDOUT "  Adding ARS scores ...\n";
	my $time0    = time;

	# Print header
	my $PROC   = $self->Open;
	open( OUT, ">$procTmp" );
	my $header = <$PROC>;
	chomp $header;
	my @header = split( "\t", $header );
	my @add    = ( 'ARS_GROUP', 'ARS_GLOBAL' );
	@header    = ( @header, @add );
	print OUT join( "\t", @header ), "\n";
	my $num;

	while( my $line = <$PROC> ){
		# 0: chrX
		# 1: 132450499 (start)
		# 2: 132450500 (end)
		# 3: A  (s_base)
		# 4: N  (w_base)
		# 5: 11 (s_reads)
		# 6: 0  (w_reads)
		# 7: 0  (ws_ratio)
		# 8: g  (i:imputed or g:genotyped)
		chomp $line;
		my @split = split( "\t", $line );

		# Find out if the SNP has concordant s_bases
		my @bases    = split( ',', $split[3] );
		my @sReads   = split( ',', $split[5] );
		my @wReads   = split( ',', $split[6] );
		my @wsRatios = split( ',', $split[7] );
		my %sSame;
		my %sReads;
		my %wReads;
		my %wsRatios;

		for( my $i = 0; $i < scalar @bases; $i++ ){
			my $base   = $bases[$i];
			my $sReads = $sReads[$i];
			my $wReads = $wReads[$i];
			my $ratio  = $wsRatios[$i];
			next if $wReads <= 0;

			$sSame{$base}++;
			push( @{$sReads{$base}},   $sReads );
			push( @{$wReads{$base}},   $wReads );
			push( @{$wsRatios{$base}}, $ratio );
		}
		next unless keys %sSame > 0;
		$num++;

		# Go through each group found
		my @arsGroup;
		my $arsHigh = 1; # >= 0.5
		my $arsLow  = 1; # <  0.5
		my %arsVote;

		for my $base ( keys %sSame ){
			my $numExp   = $sSame{$base};
			my $readsAvg = 0;
			my $ratioAvg = 0;
			my $maxSum   = 0;

			# Calculate average reads and ratio within each group
			for( my $i = 0; $i < scalar @{$sReads{$base}}; $i++ ){
				my $sum    = $sReads{$base}[$i] + $wReads{$base}[$i];
				$maxSum    = $sum if $sum > $maxSum;

				$readsAvg += $sReads{$base}[$i];
				$ratioAvg += $wsRatios{$base}[$i];
			}
			$readsAvg /= $numExp;
			$ratioAvg /= $numExp;

			my $num  = $numExp;
			$num     = 3 if $num > 3;
			my $ars  = $ArScores->get_ars_score(
				$num,
				$ratioAvg,
				$readsAvg,
			);
			push( @arsGroup, "$numExp$base\_$ars" );

			if( $ars >= 0.5 ){
				$arsHigh++;
			}
			else{
				$arsLow++;
			}
			$arsVote{"$numExp$base"} = [$numExp, $maxSum, $ars];
		}

		# Get best ars score and filter out if maxSum doesn't cut it
		my @sorted  = sort{ $arsVote{$b}[0] <=> $arsVote{$a}[0] } keys %arsVote;
		my $key1    = shift @sorted;
		my $numExp1 = $arsVote{$key1}[0];
		my $numExp2 = 0;
		my $numExps = keys %arsVote;

		for my $key ( @sorted ){
			$numExp2 += $arsVote{$key}[0];
		}

		# Report ARS score if cadidate meets criteria or report -1
		my $maxNum  = $arsVote{$key1}[1];
		my $arsGlob = -1;

		if( $numExp1 > $numExp2 ){
			$arsGlob = $arsVote{$key1}[2];
		}
		elsif( $arsHigh/$arsLow <= 0.4 ){
			# Less than 30% of the groups have a high ARS value
			$arsGlob = $arsVote{$key1}[2];
		}

		my $arsGroup  = join( ',', @arsGroup );
		my @addScores = ( $arsGroup, $arsGlob );

		@split = ( @split, $arsGroup, $arsGlob );
		print OUT join( "\t", @split ), "\n";
	}
	$self->Close;
	close OUT;

	if( $num > 1 && -s $procTmp ){
		print STDOUT "    Number of concordant alleles = $num\n";
		`mv $procTmp $procFile`;
	}
	else{
		print STDOUT "    Failed to add AR scores!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub	add_reference_bases
{
	my $self     = shift;
	my $procFile = $self->get_file;
	my $outDir   = $self->get_outDir;
	my $Config   = $self->{'config'};
	my $genome   = $Config->get_value( 'REFGEN_FILE' );
	my $bedtools = $Config->get_value( 'BEDTOOLS' );
	my $refFile  = "$procFile.ref";

	print STDOUT "  Annotating reference allele ... \n";
	my $time0    = time;

	# Generate BED file with base coordinates
	my $bedFile  = "$outDir/reference.bed";
	`tail -n +2 $procFile | awk '{print \$1,\$2-1,\$2}' OFS='\\t' > $bedFile`;

	# Get genomic bases
	my @refBases = `$bedtools getfasta -fi $genome -bed $bedFile -tab -fo /dev/stdout | cut -f2 | tr "[:lower:]" "[:upper:]"`;
	chomp @refBases;

	#  Write header
	my $PROC   = $self->Open;
	open( OUT, ">$refFile" ) or
		die "ERROR: Could not open file $refFile!\n";
	my $header = <$PROC>;
	chomp $header;
	my @header = split( "\t", $header );
	splice( @header, 3, 0, 'REF_BASE' );
	print OUT join( "\t", @header ), "\n";

	my $num = 0;

	while( my $line = <$PROC> ){
		chomp $line;
		my @split   = split( "\t", $line );
		my $refBase = $refBases[$num];
		splice( @split, 3, 0, $refBase );

		print OUT join( "\t", @split ), "\n";
		$num++;
	}
	$self->Close;
	close OUT;

	if( $num > 0 && -s $refFile ){
		print STDOUT "    Number of processed lines = $num\n";
		`head -n1 $refFile > $procFile`;
		`tail -n +2 $refFile | awk '{print \$1,\$2-1,\$0}' OFS='\t' | cut -f1,2,5- | sort -Vk1,1 -k2,2n >> $procFile`;
		`rm -f $refFile $bedFile`;
	}
	else{
		print STDOUT "    Failed to add reference bases!\n";
		`rm -f $refFile`;
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1,
}

sub find_motif_matches
{
	my $self     = shift;
	my $mFiles   = shift;
	my $procFile = $self->get_file;
	my $outDir   = $self->{'outDir'};
	my $Config   = $self->{'config'};

	print STDOUT "  Finding motif matches ...\n";
	my $time0        = time;

	# Load MOTIFS
	my $motifs  = $self->_load_motifs( $mFiles );
	if( !$motifs ){
		print STDOUT "    Failed loading motifs!\n";
		return 0;
	}

	# Extract genomic sequences
	print STDOUT "    Extracting REF sequences\n";
	my $refSeqs = $self->_extract_ref_sequences;
	if( !$refSeqs ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	# Print allele sequences to a temporary FASTA file
	print STDOUT "    Building allele sequences\n";
	my $allele_seqs = $self->_build_allele_sequences( $refSeqs );
	if( !$allele_seqs ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	# Find MOTIF matches
	print STDOUT "    Finding matches\n";
	my $matches = $self->_find_matches( $allele_seqs, $motifs );
	if( !$matches ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	# print_results
	print STDOUT "    Writing results\n";
	my $status  = $self->_write_match_results( $matches );
	if( !$status ){
		print STDOUT "    Failed!\n";
		return 0;
	}

	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

sub _load_motifs
{
	my $self   = shift;
	my $mFiles = shift;
	my $outDir = $self->{'outDir'};
	my $Config = $self->{'config'};
	my @motifs;

	if( -s $mFiles ){
		open( MAT, $mFiles ) or (
			print STDOUT "    Could not open file: $mFiles at '_load_motifs'\n" and
			return 0
		);

		while( my $m_file = <MAT> ){
			chomp $m_file;

			if( -s $m_file ){
				my $Motif = new MOTIF(
					file       => $m_file,
					outDir    => $outDir,
					config => $Config,
				);
				push( @motifs, $Motif );
			}
		}
		return \@motifs if @motifs;
	}
	return 0;
}

sub _extract_ref_sequences
{
	my $self     = shift;
	my $procFile = $self->get_file;
	my $outDir   = $self->{'outDir'};
	my $Config   = $self->{'config'};
	my $padding  = $Config->get_value('SNP_PADD');
	my $genome   = $Config->get_value('REFGEN_FILE');
	my $bedtools = $Config->get_value('BEDTOOLS');

	# Generate BED file using padded regions around each SNP
	my $bedFile = "$outDir/refSeqs.bed";
	`tail -n +2 $procFile | awk '{print \$1,\$2-$padding,\$2+$padding-1}' OFS='\\t' > $bedFile`;

	my $refFile = "$outDir/refSeqs.txt";
	`$bedtools getfasta -fi $genome -bed $bedFile -tab -fo /dev/stdout | cut -f2 > $refFile`;
	`rm -f $bedFile`;

	return $refFile if -s $refFile;
	return 0;
}

sub _build_allele_sequences
{
	my $self     = shift;
	my $refFile  = shift;
	my $procFile = $self->get_file;
	my $outDir   = $self->{'outDir'};
	my $Config   = $self->{'config'};
	my $padding  = $Config->get_value( 'SNP_PADD' );
	my $seqFile  = "$outDir/allele_sequences.fasta";

	my $IN     = $self->Open;
	my $header = <$IN>;
	open( SEQ, $refFile ) or
		die "ERROR: Could not open file: $refFile at '_build_allele_sequences'\n";
	open( OUT, ">$seqFile" ) or
		die "ERROR: Could not create file: $seqFile at '_build_allele_sequences'\n";

	# Print header
	print OUT ">allele-sequences\n";

# 0 CHR
# 1 START
# 2 END
# 3 REF_BASE
# 4 S_BASE
# 5 W_BASE
# 6 S_READS
# 7 W_READS
	while( my $line = <$IN> ){
		chomp $line;
		my @split   = split( "\t", $line );
		my $r_base  = $split[2];
		my @s_bases = split( ',', $split[3] );
		my @w_bases = split( ',', $split[4] );
		my $ref_seq = uc <SEQ>;
		chomp $ref_seq;

		# Get most abundant s_base
		my %bases;

		for my $base ( @s_bases ){
			$bases{$base}++;
		}
		my @sorted = sort{ $bases{$b} <=> $bases{$a} } keys %bases;
		my $s_base = $sorted[0];

		# Get most abundant w_base
		my $w_base;

		for my $base ( @w_bases ){
			$bases{$base}++;
		}
		@sorted = sort{ $bases{$b} <=> $bases{$a} } keys %bases;

		for my $base ( @sorted ){
			next if $base eq 'N';
			$w_base = $base;
		}
		$w_base = 'N' if !$w_base;

		# Print sequences for both alleles
		my $s_seq = $ref_seq;
		my $w_seq = $ref_seq;

		if( $s_base eq $r_base ){
			substr( $s_seq, $padding, 1, $s_base );
			substr( $w_seq, $padding, 1, $w_base );
			print OUT "$s_seq$w_seq";
		}
		else{
			substr( $s_seq, $padding, 1, $w_base );
			substr( $w_seq, $padding, 1, $s_base );
			print OUT "$s_seq$w_seq";
		}
	}
	print OUT "\n";

	$self->Close;
	close SEQ;
	close OUT;

	# Remove reference file (no longer used)
	`rm -f $refFile`;

	return $seqFile if -s $seqFile;
	return 0;
}

sub _find_matches
{
	my $self     = shift;
	my $seqFile  = shift;
	my $motifs   = shift;
	my $procFile = $self->get_file;
	my $outDir   = $self->{'outDir'};
	my $Config   = $self->{'config'};
	my $padding  = $Config->get_value('SNP_PADD');
	my $moods    = $Config->get_value('MOODS');
	my $pval_cf  = $Config->get_value('MOODS_PVAL');

	# Generate temporary motif files
	my @fw_motif_files;
	my @rc_motif_files;

	for my $Motif ( @$motifs ){
		my $m_file  = $Motif->get_file;
		my $m_base  = $Motif->get_base;
		my $fw_file = $Motif->get_forward_file;
		my $rc_file = $Motif->get_reverse_file;
		push( @fw_motif_files, $fw_file );
		push( @rc_motif_files, $rc_file );
	}
	my $fw_motif_list = join( ' ', @fw_motif_files );
	my $rc_motif_list = join( ' ', @rc_motif_files );

	# Run MOODS
	# MOODS produces zero-based positions in its output
	my @fw_out = `$moods -f $pval_cf $seqFile $fw_motif_list 2>&1 | grep -vP "^(cal|loa|Mat|Hit|Tot|\\n+)" | awk 'NF'`;
	my @rc_out = `$moods -f $pval_cf $seqFile $rc_motif_list 2>&1 | grep -vP "^(cal|loa|Mat|Hit|Tot|\\n+)" | awk 'NF'`;

	# Remove sequences file (no longer used)
	`rm -f $seqFile`;

	# Process MOODS output
	my $fw_moods_out  = _read_moods_output( \@fw_out );
	my $rc_moods_out  = _read_moods_output( \@rc_out );

	# Deconvolute MOODS output
	my $fw_matches    = _deconvolute_moods_hits( $fw_moods_out, $motifs, $padding );
	my $rc_matches    = _deconvolute_moods_hits( $rc_moods_out, $motifs, $padding );
	my @matches       = ( $fw_matches, $rc_matches );

	# Remove matrix files and canonical sequence fasta files (no longer used)
	`rm -f *.mat *canonical.fa`;

	return \@matches;
}

sub _read_moods_output
{
	my $output = shift;
	my %moods_out;
	my $m_base;
	my @scores;

	while( my $line = shift @$output ){
		chomp $line;

		if( $line =~ /^\d/ ){
			push( @scores, $line );
		}
		else{
			if( @scores ){
				my @cp_scores = @scores;
				$moods_out{$m_base} = \@cp_scores;
				undef @scores;
			}

			$m_base = $line;
			$m_base =~ s/^.*\///;
			$m_base =~ s/_(fw|rc)\.mat$//;
		}
	}
	$moods_out{$m_base} = \@scores;

	return \%moods_out;
}

sub _deconvolute_moods_hits
{
	my $moods_out = shift;
	my $motifs    = shift;
	my $padding   = shift;
	my %matches;

	for my $Motif ( @$motifs ){
		my $m_base  = $Motif->get_base;
		my $m_len   = $Motif->get_motif_length;
		my $c_score = $Motif->get_canonical_score;
		my $hits    = $moods_out->{$m_base} or next;

		my $hit     = shift @$hits;
		my $i       = 0;
		my $snp_pos = ( 2 * $i + 1 ) * $padding;
		# MOODS produces zero-based positions in its output
		my(
			$h_start,
			$score,
		) = split( "\t", $hit );
		my $h_end   = $h_start + $m_len - 1;
		
		do{
			my $aa = sprintf( "%.3f",$score/$c_score );
			if( $h_start > $snp_pos + $padding - 1 ){
				$i++;
				$snp_pos = ( 2 * $i + 1 ) * $padding;
			}
			elsif( $h_start <= $snp_pos and $snp_pos <= $h_end ){
				# Correct h_start and h_end
				my $rel_start = $h_start - $i * 2 * $padding;
				my $rel_end   = $rel_start + $m_len - 1;

				push( @{$matches{$i}{"$m_base:$rel_start:$rel_end"}}, ($score, $score/$c_score) );

				$hit   = shift @$hits;
				(
					$h_start,
					$score,
				) = split( "\t", $hit );
				$h_end = $h_start + $m_len - 1;
			}
			else{
				$hit   = shift @$hits;
				(
					$h_start,
					$score,
				) = split( "\t", $hit );
				$h_end = $h_start + $m_len - 1;
			}
		} until( scalar @$hits == 0 );
	}

	return \%matches;
}

sub _write_match_results
{
	my $self     = shift;
	my $matches  = shift;
	my $procFile = $self->get_file;
	my $hitFile  = $self->get_hitFile;
	my $Config   = $self->{'config'};
	my $score_cf = $Config->get_value( 'MIN_SCORE' );
	my $padding  = $Config->get_value( 'SNP_PADD' );
	my $tmpFile  = "$hitFile.tmp";

	if( scalar @$matches == 0 ){
		print STDOUT "    No motif matches found\n";
		return 0;
	}

	open( OUT, ">$tmpFile" ) or
		die "    Failed to create file: $tmpFile!\n";

	my $PROC   = $self->Open;
	my $header = <$PROC>;
	chomp $header;
	my @header = split( "\t", $header );

	my @hit_header = (
	 	'MOTIF_NAME',
		'TF_NAME',
		'HIT_START',
		'HIT_END',
		'HIT_LENGTH',
		'HIT_STRAND',
		'HIT_SCORE_1',
		'HIT_SCORE_2',
		'HIT_NORM_SCORE_1',
		'HIT_NORM_SCORE_2',
	);
	push( @header, @hit_header );
	print OUT join( "\t", @header ), "\n";

	my $i = 0;

	while( my $line = <$PROC> ){
		chomp $line;
		my @split = split( "\t", $line );
		my $start = $split[1];
		my $sign  = '+';

		# Go through each match type (fw and rc)
		for my $match ( @$matches ){
			# Hits on allele 1
			if( $match->{$i} ){
				# {$i} = [{$m_base:$rel_start:$rel_end} = [$score, $score/$c_score]]
				for my $h_coor ( keys %{$match->{$i}} ){
					my(
					 	$m_base,
						$h_start,
						$h_end,
					) = split( ':', $h_coor );
					# Get motif length
					my $m_len = $h_end - $h_start + 1;
					# Correct h_start and h_end relative to SNP position
					$h_start = $h_start - $padding;
					$h_end   = $h_end   - $padding;

					my(
					 	$m_code,
						$m_version,
						$tf_name,
					) = split( '_', $m_base );
					my $m_name = "$m_code\_$m_version";

					my(
						$score1,
						$n_score1,
					) = @{$match->{$i}{$h_coor}};
					next if $n_score1 < $score_cf;

					# Hits on allele 2
					if( $match->{$i+1}{$h_coor} ){
						# {$i} = [{$m_base:$rel_start:$rel_end} = [$score, $score/$c_score]]
						my(
							$score2,
							$n_score2,
						) = @{$match->{$i+1}{$h_coor}};

						if( $n_score1 > $n_score2 ){
							my @hit = (
								$m_name,
								$tf_name,
								$h_start,
								$h_end,
								$m_len,
								$sign,
								sprintf( "%.3f", $score1 ),
								sprintf( "%.3f", $score2 ),
								sprintf( "%.3f", $n_score1 ),
								sprintf( "%.3f", $n_score2 ),
							);
							push( @split, @hit );
							print OUT join( "\t", @split ), "\n";
						}
					}
					else{
						my @hit = (
							$m_name,
							$tf_name,
							$h_start,
							$h_end,
							$m_len,
							$sign,
							sprintf( "%.3f", $score1 ),
							'0.000',
							sprintf( "%.3f", $n_score1 ),
							'0.000',
						);
						push( @split, @hit );
						print OUT join( "\t", @split ), "\n";
					}
				}
			}
			$sign = '-';
		}
		$i += 2;
	}
	$self->Close;
	close OUT;

	`head -n1 $tmpFile > $hitFile`;
	`tail -n +2 $tmpFile | sort -nrk15,15 -k1,1V -k2,2n >> $hitFile`;
	`rm -f $tmpFile`;

	return 1;
}

sub annotate
{
	my $self     = shift;
	my $aFile    = shift;
	my $Config   = shift;
	my $outDir   = shift;
	my $bedtools = $Config->get_value('BEDTOOLS');
	my $chroms   = $Config->get_value('CHROMOSOMES');
	my $bFiles   = $Config->get_value('ANNO_FILES');

	print STDOUT "  Annotating $aFile\n";

	for my $bFile ( @$bFiles ){
		# Create "a" BED file by removing the header
		my $aBed     = $aFile . '.bed';
		`tail -n +2 $aFile | sort -Vk1,1 -k2,2n > $aBed`;
		# Get "a" header (excluding the first 3 which are coordinates)
		my $aHeader  = `cut -f4- $aFile | head -n1`; chomp $aHeader;
		# Count number of fields in header
		my @aFields  = split( "\t", $aHeader );
		my $naFields = scalar @aFields;
		my @annoLines;

		# Create "b" BED file by removing the header
		my $bBed = $bFile;
		$bBed    =~ s/^.*\//$outDir\//;
		`tail -n +2 $bFile | sort -Vk1,1 -k2,2n > $bBed`;

		# Get "b" header (excluding the first 3 which are coordinates)
		my $bHeader  = `cut -f4- $bFile | head -n1`; chomp $bHeader;
		# Count number of fields in header
		my @bFields  = split( "\t", $bHeader );
		my $nbFields = scalar @bFields;

		# Find closest feature using "bedtools closest"
		for my $chrom ( @$chroms ){
			my $acBed = "$aBed.$chrom";
			my $bcBed = "$bBed.$chrom";
			`grep -P "^$chrom\t" $aBed > $acBed`;
			`grep -P "^$chrom\t" $bBed > $bcBed`;
			next if !-s $acBed;

			my @chrLines;
			if( -s $bcBed ){
				my $s     = $naFields + 3;
				my $e     = $s + 4;
				@chrLines = `$bedtools closest -D "a" -a $acBed -b $bcBed | grep -v "^\\." | cut -f1-$s,$e- 2> /dev/null`;
			}
			else{
				my $dummy = join( "\t", ('na') x $nbFields );
				@chrLines = `awk '{print \$0,"$dummy"}' OFS='\\t' $acBed`;
			}
			push( @annoLines, @chrLines );
		}
		# Remove temporary BED files (no longer used)
		`rm -f $aBed.chr* $bBed.chr* $bBed`;

		# Attach annotation to aBed lines
		my $tmpOut = "$outDir/tmpAnnoLines.asb";
		open( OUT, ">$tmpOut" ) or
			die "ERROR: Could not create file $tmpOut\n";

		# Print annotated header
		my @header = (
			'CHR',
			'START',
			'END',
			$aHeader,
			$bHeader,
			'DIST',
			'ABS_DIST',
		);
		print OUT join( "\t", @header ), "\n";

		for my $line ( @annoLines ){
			chomp $line;
			my @split      = split( "\t", $line );
			my $snpDist    = $split[-1];
			my $absSnpDist = 'na';
			$absSnpDist    = abs $snpDist if $snpDist ne 'na';

			print OUT "$line\t$absSnpDist\n";
		}
		close OUT;

		if( -s $tmpOut ){
			my $bBase = $bFile;
			$bBase    =~ s/.*\///;
			print STDOUT "    Annotated using file: $bBase\n";

			# Sort file in descending order by ARS values
			`head -n1 $tmpOut > $aFile`;
			`tail -n +2 $tmpOut | sort -nrk15,15 -k1,1V -k2,2n >> $aFile`;
			`rm -f $tmpOut $aBed`;
		}
		else{
			print STDOUT "    Failed!\n";
			`rm -f $aFile $tmpOut $aBed`;
			return 0;
		}
	}
	my $time1   = time;
	my $elapsed = sprintf( "%.2f", ( $time1 - $time0 ) / 60 );
	print STDOUT "  Time elapsed: $elapsed min\n";

	return 1;
}

1;
